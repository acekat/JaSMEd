\documentclass[12pt,a4paper]{article}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[final]{pdfpages}
\usepackage{fullpage}
\usepackage{setspace}

\usepackage{url}
\usepackage{graphicx}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\jasmed}{\texttt{JaSMEd}}

\begin{document}

\input{./couverture.tex}


\begin{center}
{\huge \bfseries Sujet}\\[1.5cm]
\end{center}
{\Large \bfseries Editeur musical collaboratif en JavaScript}

\bigskip
La nouvelle interface WebSocket permet d’utiliser les navigateurs pour implémenter facilement en JavaScript des applications collaboratives et interactives. Ajoutée à la nouvelle interface WebAudio, on peut en particulier concevoir un éditeur de pistes musicales affiché par un navigateur Web standard, sur lequel opère à la fois l’utilisateur du navigateur et ses correspondants.\\
Le but du projet est de développer un tel éditeur, en traitant en particulier les problèmes d’accès concurrents à une même partie des pistes musicales éditées collaborativement. Se pose aussi la question de l’archivage sur le serveur des différents états de la partition, et la manière d’y accéder.\\
La question des protocoles audio à utiliser sera aussi abordée.

\vfill

\pagebreak

\tableofcontents

\pagebreak

\section{Introduction}

Nous avons proposé JaSMEd car il s'inscrit à la fois dans le domaine des applications réparties, et reflète nos orientations musicales dans la pratique de l'informatique. C'est dans un cadre internet en constante transformation que l'on a développé JaSMEd, une application client/serveur qui tire partie des nouvelles API d’HTML5.

\medskip
JaSMEd est un éditeur musical multi-utilisateur temps réel implémenté à partir des nouveaux standards du web qui tire sa spécificité de part son approche de composition polyrythmique\footnote{Superposition de plusieurs parties ayant chacune un rythme différent et dont les accents d'appui ne coïncident pas entre eux (Larousse de la Musique, Paris, t. 2, 1982, p. 1247).}. Actuellement il n'existe pas d'outils pour créer une polyrythmie musicale de manière collaborative. En général il n'y a pas de moyens simples permettant d'écrire ce genre de rythmes complexes, et encore moins sur internet où la majeure partie des applications musicales ne sont pas de véritables outils de composition. C'est en faisant ce constat que nous est apparue l'idée de développer JaSMEd. De part son approche de l'édition web collaborative, notre travail s'inscrit parfaitement dans le cadre du master Systèmes et Applications Répartis.\\
Il faut préciser que notre application n’est encore qu’à sa première version, elle est fonctionnelle mais ne représente pas encore complètement l'ampleur du projet.

\medskip
Dans ce rapport nous nous efforcerons de donner au lecteur des informations et raccourcis qui sont le fruit de nos recherches et de nos propres expériences sur le sujet du web et de l’audio. Nous détaillerons dans un premier temps la conception de JaSMEd et ses idées directrices qui ont sous-tendu son développement. Puis nous aborderons l’implémentation de l’application avec les technologies utilisées et les solutions apportées pour aboutir au rendu souhaité.

\section{État de l'art}


\section{Conception}

Avant de nous lancer dans l’implémentation de l’application nous avons longuement réfléchis à une conception efficace du problème car nous le savions complexe. Nous voulions une application dont la prise en main soit facile, qui soit performante et innovante, et enfin qui puisse être facilement améliorée par la suite.\\
Nous décrivons ici les trois grands axes de réflexion qui nous ont permis de démarrer l’application sur de bonnes bases.

\subsection{Structures}

\subsubsection{Musicale}

\subsubsection{Visuelle}

Pour ce qui concerne le rendu graphique de l’application, il est intéressant de séparer la vue des données, à la manière d’une architecture MVC. Une fois la vue correctement liée au changement des modèles, on ne s’occupe plus que de la modification des données et la vue suit automatiquement. De plus ceci a un avantage dans la réutilisation du code des modèles côté serveur comme nous le verront dans la section archivage.\\
La structure des données de l’affichage est en quelque sorte conditionnée par les possibilités du couple HTML5/CSS3. Cependant celui-ci a beaucoup évolué dans ses dernières versions respectives, et nous permet d’obtenir le rendu que nous souhaitions. L’éditeur est alors composé de plusieurs blocs, chacun contenant une pile de calques avec un unique calque éditable par bloc. Les blocs peuvent être ajoutés ou supprimés, afin de faire varier la taille de la grille d’édition. Un calque est un tableau où chaque ligne représente une hauteur et une case une division dans le temps. Les calques sont caractérisés par leur nombre de subdivision, on peut en créer de nouveau ou échanger leur ordre dans la pile, le calque du dessus est celui éditable. C’est à travers les calques éditables de chaque bloc que l’on peut faire des sélections de subdivisions afin d’activer ou désactiver des notes.

\bigskip
L’usage de cette représentation novatrice sous forme de calques incarnant chacun une division du bloc en temps égaux permet d’appréhender le rythme, et surtout la polyrythmie, sous un aspect simpliste voire ludique, exempt de toute référence solfégique culturelle. De cette manière, il est ainsi possible de représenter tout type de musique rythmique, quelque soit sa structure. Nous nous somme volontairement éloigné des usages occidentaux (mesures, signature rythmique) pour offrir un maximum de liberté.\\
Afin de permettre des écarts vers des divisions inégales, principalement à des fins d’interprétation musicale, la création d’un outil appropriée est envisagée.

\subsection{Collaboration}

Un point innovant du projet et qui justifie l’utilisation de technologies récentes, est la collaboration temps réel entre plusieurs client. Le choix de développer l’application dans un navigateur web peut paraître restrictif à première vue, mais il apporte une plus grande facilité de développement pour son aspect collaboratif.\\
En effet, le nouveau protocole WebSocket\footnote{RFC6455, décembre 2011: \url{http://tools.ietf.org/html/rfc6455}} permet de faire communiquer le navigateur web du client et le serveur web de manière bi-directionnelle et full-duplex, ce qui est alors indispensable pour répercuter les changements d’un client à l’autre dans un lapse de temps raisonnable. Ainsi toute modification locale apportée à l’éditeur par un client est envoyée au serveur, qui à son tour broadcast l’information aux autres clients.\\
Seulement cette synchronisation introduit différents problèmes dont voici une analyse.

\subsubsection{Concurrence}

\subsubsection{Archivage}

Permettre à un client de se joindre à l’élaboration d’un morceau en cours de route, implique qu’une version synchronisé du morceau peut être récupérée à tout moment sur le serveur. Il faut donc garder une copie des données sur le serveur et les mettre à jour au même moment où le serveur reçois des modifications de la part d’un client.\\
Pour cela nous pouvons utiliser sur le serveur les deux structures de données (musicale et visuelle) présentes côté client. Elles seront alors maintenues synchronisées de la même manière que celles des clients, à l’aide des messages échangés entre ces derniers. Puis à la connexion d’un nouveau client, ou bien lorsqu’un client souhaitera recharger son application, le serveur pourra exporter le contenu des deux structures, afin que le client puisse initialiser ses structures locales dans le même état que celles du serveur. Il faut alors ajouter des fonctions d’importation et d’exportation du contenu des deux structures. Le fait d’utiliser le même langage côté serveur et côté client, est ici un avantage, car il permet la réutilisation du code.

\subsection{Modularité}


\section{Implémentation}

\subsection{Technologies utilisées}

\subsubsection{Confort de développement}

Une part importante de la réussite d’un projet en équipe réside dans la collaboration entre les membres de l’équipe. C’est pour cela que nous avons tenu dès le début à mettre en place des outils pour faciliter cette collaboration.\\
Nous avons commencé par partager des Google Docs, afin de fixer les choix aussi bien de conception que d’implémentation, de manière à avoir des documents de référence. Y est répertorié toute la documentation qui nous a aidé au développement de l’application, mais aussi les différents modules qui composent l’application et les messages échangés entre eux.\\
Ensuite, durant notre documentation, nous avons remarqué que beaucoup de projets open-source que nous utilisons ont un dépôt GitHub pour faire participer la communauté au développement. C’est alors un moyen facile pour nous de mettre en commun le développement de l’application, dans un premier temps entre les membres de l’équipe du projet, mais aussi par la suite à toute autre personne souhaitant participer au projet.\\
Nous avons alors découvert Git pour la gestion des versions en local, qui s’avère être un outils presque indispensable dans le développement d’une application telle que JaSMEd.\\
Le code source de JaSMEd est donc disponible sur le dépôt GitHub à l’adresse suivante: \url{https://github.com/Acekat/JaSMEd}. Nous avons pris le partie de commenter et rédiger notre code en anglais, afin de permettre au plus grand nombre de participer au projet.

\subsubsection{JavaScript et ses bibliothèques}

Toutes les bibliothèques que nous avons utilisées, aussi bien du côté client que du côté serveur, sont écrites en JavaScript. C’est pourquoi nous présentons d’abord le langage d’une manière générale, avant de détailler chacune des bibliothèques utilisées.

\paragraph{JavaScript}~\\
Le JavaScript (JS) dont le nom exact est ECMAScript est un langage de haut niveau, dynamique, non typé et interprété. Il est standardisé par l’ECMA Internationnal et est l’unique\footnote{Dart et NaCl éxistent aussi maintenant.} langage de programmation proposé par les navigateurs web.\\
Ces dernières années il a bénéficié d’interpréteurs de plus en plus rapides et performants et récemment sa popularité s’est encore accrue grâce à une technologie prometteuse nommée node.js qui permet d’utiliser le langage pour développer entre autres des serveurs web très facilement.\\
C’est pour cela que nous avons choisi de construire JaSMEd exclusivement en JavaScript.\\
Il a cependant fallu apprendre les spécificités du langage, telles que les closures, l’héritage prototypal (pas de classes... tout est une instance), ou l’aspect dynamique de \texttt{this} entre autres. Le langage présente quand même quelques aspects peu pratiques, notamment le fait qu’il n’y ait pas de modularité nativement, soit un seul espace d’exécution (pas de paquetage comme en Java) ce qui implique des conflits potentiels de variables globales.\\
Les livres \emph{JavaScript: The Good Parts}~\cite{Crockford} et \emph{JavaScript: The Definitive Guide}~\cite{Flanagan} sont les “bibles” du javascript et nous ont permis de comprendre mieux le langage et d’appréhender ses spécificités et les défauts.

\paragraph{Node.js}\url{http://nodejs.org/}\\
Node.js est un framework évènementiel pour la machine virtuelle JavaScript V8. Nous l’avons utilisé pour développer le serveur de JaSMEd.
La philosophie de Node est que toute opération d’entrée/sortie doit être asynchrone, c’est à dire doit prendre en paramètre une fonction de rappel.\\
Node incorpore un système de module qui suit la spécification CommonJS (et permet donc l'exécution de code JS dans des contextes différents si désiré). Il propose par défaut des modules qui gèrent les protocoles fondamentaux tels que le HTTP ou le DNS ce qui le rend très intéressant pour développer des serveurs. En effet l’aspect asynchrone tend à le rendre plus réactif que le modèle bloquant (tel que le serveur apache, même si dans la dernière version celui-ci propose également un modèle asynchrone...) et donc plus adapté pour des applications temps réel.\\
Node est fourni avec un système de gestion de module nommé npm (similaire à rubyGems) qui permet aux développeurs de publier leurs modules node aisément.\\
Il y a de plus en plus de développeurs qui s’intéressent à Node et donc de plus en plus de modules intéressant sont disponibles. Notre application est construite à l’aide de deux modules qui ont largement contribué à la popularité croissante de node du fait de leurs simplicité, robustesse et qualités: Express et Socket.io.

\paragraph{Express}\url{http://expressjs.com/}

\paragraph{Socket.io}\url{http://socket.io/}\\
Socket.io est un module de node.js facilitant la communication client/serveur “tempsréel” et ayant pour but de fonctionner sur tous les navigateurs. Il est donc présent du côté client et du côté serveur. Il permet d’abstraire le moyen de communication qui sera utilisé. Pour cela, il détecte les technologies disponibles sur les clients et utilise celle qui est considérée comme la meilleure en rapidité de communication. C’est-à-dire en priorité le protocole WebSocket si celui-ci est supporté; si ce n’est pas le cas il utilise l’AJAX (polling XHR); si il ne supporte pas l’AJAX il utilisera les sockets Flash, et caetera.\\
C’est une bibliothèque bien documenté et très robuste seulement, après réflexion il se trouve que ce n’est pas la meilleure solution pour JaSMEd. En effet JaSMEd fonctionne exclusivement sur les navigateurs modernes et ces derniers disposent tous du protocole WebSocket. Il serait donc plus adapté d’utiliser le module ws, qui est considéré comme le plus rapide car il n’utilise que le protocole WebSocket.

\paragraph{jQuery}\url{http://jquery.com/}\\
jQuery est une bibliothèque qui abstrait la plupart des actions/possibilités offertes par les navigateurs web comme la manipulation du DOM, la gestion d’évènements, les animations et les interactions AJAX.\\
Il existe de nombreuses bibliothèques similaires mais nous avons opté pour celle-ci dans un premier temps car elle est la mieux documenté, la plus populaire et la plus performante. Seulement celle-ci présente quelques inconvénients, surtout sa taille conséquente (32 Ko pour la version minifiée) — qui vient du fait que jQuery est compatible avec nombreux navigateurs anciens (IE < 9, Firefox < 4, Safari < 5) — et son aspet monolithique (jQuery propose énormement de fonctionnalitées, nous ne tirons pas partie de toutes celles-ci).\\
À plusieurs reprise nous avons pensé à opter pour une bibliothèque plus récente et donc plus adapté. Notamment Ender mais surtout Zepto, qui a été conçue pour les navigateurs récents et propose une API très proche de celle de jQuery mais plus modulaire (Ajax, évènements, effets/animations sont des modules).\\
JaSMEd n’est fonctionnel que sur les navigateurs les plus récents et donc l’utilisation de Zepto semble beaucoup plus adaptée. C’est d'ailleurs une des modifications prévues à court terme.

\paragraph{Underscore}\url{http://underscorejs.org/}\\
Underscore est une bibliothèque qui fournit des outils pour la programmation fonctionnelle (\texttt{map}, \texttt{reduce}, \texttt{filter}, etc...) ainsi que des extensions à JS pour manipuler les structures de données plus simplement (\texttt{Collection.size}, \texttt{max/min}, \texttt{Array.contains}). Elle est très utilisé car elle n’étend pas les objets natifs du JS (ce qui évite des problèmes de compatibilité) et utilise les méthodes "natives" si jamais celles-ci sont disponibles (map, filter etc... font partie de la spécification de l’ECMAScript 5\footnote{Standard ECMA-262, juin 2011: \url{http://ecma-international.org/ecma-262/5.1/}}). Elle est très utile pour améliorer la qualité et la lisibilité du code.

\paragraph{Backbone}\url{http://backbonejs.org/}\\
Backbone permet de structurer les applications web. Elle fournit des \texttt{Model}, des \texttt{Collection} ainsi que des \texttt{View} pour aboutir à une organisation MV*, différente du MVC dans son absence de Contrôleur à part entière. Les \texttt{Model} structurent les données (de la même manière qu’en MVC), les \texttt{Collection} sont de simples listes de \texttt{Model}, et ce sont les \texttt{View} qui, en plus de leur rôle habituel en MVC, intègre un contrôle de l’interaction avec les données.\\
Il y a une multitude de bibliothèques JS visant à aider à une structure MVC. Nous avons quelques temps analysés les différentes options telles que ember.js, spine.js, knockout.js, etc... mais nous avons choisi Backbone.js du fait de sa popularité, sa légèreté et sa documentation. Backbone est assez simple, et nous a permis de structurer notre code client d’une façon claire. De plus Backbone dépend d’Underscore et jQuery (ou Zepto ou Ender aux choix), deux bibliothèques que nous utilisons déjà.

\paragraph{Audiolib}\url{http://audiolibjs.org/}\\
Audiolib fournit entre-autres une API permettant la synthèse et la lecture de son dans un navigateur web en abstrayant les différences entre les API audio expérimentaux de Google et Mozilla (webAudio API et AudioData API respectivement). La bibliothèque est en général assez bien documentée à quelques exceptions près mais peu de projets l’utilisent, donc nous n’avions pas énormément d’exemples pour nous inspirer.\\
Nous avons opté pour cette bibliothèque car elle permet à JaSMEd de fonctionner à la fois sur les dernière versions de Google Chrome et de Firefox. Cependant — même si cela voudrait dire se restreindre seulement à Google Chrome — nous avions hésité à n’utiliser que le webAudio API car celui-ci est assez bien documenté et est utilisé par plusieurs projets open source. (la prochaine version du navigateur Safari supportera le webAudio API)\\
De plus, début mai le groupe de travail W3C de l’audio a décidé de ne poursuivre la standardisation que de l’API webAudio proposé par Google\footnote{\emph{“<olivier> RESOLVED: our new charter will document the focus on the web audio API as our audio processing spec”} sur \url{http://www.w3.org/2012/05/09-audio-minutes.html#item01}}. Nous envisageons donc de remplacer Audiolib par l’usage direct du webAudio API dans le futur, d’autant plus que son système de routage/mixage de multiples sources semble plus adapté à notre application.

\bigskip
Pour conclure on peut dire que nous avons opter dans un premier temps pour les bibliothèques les plus populaires et mieux documentés dans la majorité des cas. Cela étant surtout pour nous éviter de mauvaises surprises (bugs inattendus dans la librairie, fonctionnalités non adaptés...) mais également car les membres du groupes avaient déjà de l’expérience avec plusieurs de ces bibliothèques. Même si — comme expliqué précédemment — ce ne sont pas toujours les choix les mieux adaptés en termes de performance, ce sont les choix les plus simples/sains pour développer/expérimenter avec notre application.

\subsection{Architecture}


\section{Avancement}

\subsection{Limitations actuelles de l’application}

\subsection{Détails techniques}


\section{Manuel d'utilisation}

Ce manuel présente les possibilités offertes à l'utilisateur dans la version actuelle de JaSMEd.

\paragraph{Authentification}~\\
Avant de pouvoir accéder à l’éditeur, il faut s'authentifier. Les utilisateurs autorisés à se connecter sont pour l’instant codé directement dans le fichier \emph{authentification.js}. Nous n’avons pas encore implémenté la création de nouveaux utilisateurs, car ce n’est pas l’objectif premier de l’application. Cependant, le développement d’un système de session nous a permis de nous familiariser avec des modules de node.js comme Express.\\
Une fois authentifié, on accède à l’éditeur soit en chargeant un morceau pré-enregistré, soit en partant de zéro avec un nouveau morceau.

\paragraph{Édition}~\\
La partie édition représente une partition musicale à éditer, proposant de sélectionner une note en fonction de sa hauteur, sa durée, et sa position. Il est possible de naviguer verticalement le long des octaves du piano à l’aide de la barre de défilement mais aussi horizontalement sur l’axe du temps en plaçant la souris aux extrémités gauche et droite de la grille.\\
L’ajout d’un nouveau bloc se fait à l’aide du bouton \emph{add block}.\\
Pour ajouter un nouveau calque à un bloc il suffit de préciser le nombre de subdivision souhaité dans le champs de texte au dessus de chaque bloc puis de valider avec \emph{Entrée}. Si le calque existe déjà dans le bloc, aucun calque n’est créé, mais celui désigné par le nombre de subdivision devient alors éditable. Pour changer de calque éditable dans un bloc, il suffit de cliquer sur le bouton symbolisant le calque voulu. Un seul calque par bloc est éditable.\\
Pour créer une note, on peut sélectionner une seul cellule d’un calque, ou faire une sélection de plusieurs cellules. Pour cela, il faut cliquer sur la cellule de début et glisser la souris jusqu’à la cellule de fin de la note avant de relâcher le clique. La sélection n’est pas visible directement, car pour l’instant seules les notes activées sont affichées.\\
On ne peut pas encore supprimer de notes.\\
L'utilisateur peut aussi exporter son morceau sur le serveur en spécifiant un nom sans accents ni caractère “.” dans le champ \emph{export as}.\\
On peut agrandir ou rétrécir la largeur des blocs dans la zone d'édition à l’aide des boutons \emph{zoom in} et \emph{zoom out}.

\paragraph{Lecture}~\\
La lecture du morceau se fait à l’aide du bouton \emph{play}. Une fois lancé, ce dernier se transforme en bouton \emph{pause}, pour arrêter puis reprendre la lecture en cours. Un bouton \emph{stop} est aussi disponible pour réinitialiser la lecture.\\
\emph{Remarque:} un temps de latence entre l’appuie du bouton \emph{play} et la lecture effective du morceau est à noter.

\paragraph{Instrumentation}~\\
Le panneau d’instrumentation permet de choisir le type de l'oscillateur qui jouera la piste lors de la lecture, ainsi que de modifier l'intensité du \emph{sustain} de l'enveloppe ADSR en déplaçant le curseur.


\section{Conclusion}

\pagebreak

\begin{thebibliography}{99}

\bibitem{Crockford}
	Douglas Crockford,
	\emph{JavaScript: The Good Parts}.
	O'Reilly, 2008.

\medskip

\bibitem{Flanagan}
	David Flanagan,
	\emph{JavaScript: The Definitive Guide}.
	O'Reilly, 2011.

\medskip

\bibitem{audiolib}
	Official.fm Labs,
	\emph{Audio Library Application Programming Interface}.\\
	\url{http://audiolibjs.org/}

\end{thebibliography}

\appendix

\end{document}

pb et difficultés:
-MIDI (chap conception)
-largeur de bloc ->affichage non-cohérent, curseur de lecture
-sample décalage
-app scalable -> modulaire/gestion centralisé, MV*
-latence d'initialisation lecture