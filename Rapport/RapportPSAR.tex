\documentclass[12pt,a4paper]{article}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[french]{babel}

\usepackage[final]{pdfpages}
\usepackage{fullpage}
\usepackage{setspace}

\usepackage{url}
\usepackage{graphicx}

% BEGIN Javascipt
\usepackage{listings}
\usepackage{color}
% Solarized
\definecolor{base03}{RGB}{0,43,54}		% brblack
\definecolor{base02}{RGB}{7,54,66}		% black
\definecolor{base01}{RGB}{88,110,117}	% brgreen
\definecolor{base00}{RGB}{101,123,131}	% bryellow
\definecolor{base0}{RGB}{131,148,150}	% brblue
\definecolor{base1}{RGB}{147,161,161}	% brcyan
\definecolor{base2}{RGB}{238,232,213}	% white
\definecolor{base3}{RGB}{253,246,227}	% brwhite
\definecolor{yellow}{RGB}{181,137,0}	% yellow
\definecolor{orange}{RGB}{203,75,22}	% brred
\definecolor{red}{RGB}{220,50,47}		% red
\definecolor{magenta}{RGB}{211,54,130}	% magenta
\definecolor{violet}{RGB}{108,113,196}	% brmagenta
\definecolor{blue}{RGB}{38,139,210}		% blue
\definecolor{cyan}{RGB}{42,161,152}		% cyan
\definecolor{green}{RGB}{133,153,0}		% green

\lstdefinelanguage{JavaScript}{
	keywords=[1]{typeof, return, export, implements, import, try, catch, throw, if, else, for, in, while, do, switch, case, break},
	keywords=[2]{function, class, new, var, boolean, this},
	keywords=[3]{null, true, false, undefined},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	morestring=[b]',
	morestring=[b]"
}

\lstdefinestyle{SolarizedLight}{
	language=Javascript,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=[1]\color{yellow}\bfseries,
	keywordstyle=[2]\color{blue}\bfseries,
	keywordstyle=[3]\color{orange}\bfseries,
	commentstyle=\color{base0},
	stringstyle=\color{cyan},
	backgroundcolor=\color{base3}
}

\lstset{
	language=Javascript,				% language of the code
	style=SolarizedLight,				% style of the code
	% numbers=left,						% where to put the line-numbers
	% numberstyle=\tiny\color{gray},	% the style that is used for the line-numbers
	% stepnumber=2,						% the step between two line-numbers. If it's 1, each line will be numbered
	% numbersep=5pt,					% how far the line-numbers are from the code
	showspaces=false,					% show spaces adding particular underscores
	showstringspaces=false,				% underline spaces within strings
	showtabs=false,						% show tabs within strings adding particular underscores
	tabsize=2,							% sets default tabsize to 2 spaces
	breaklines=true,					% sets automatic line breaking
	breakatwhitespace=false,			% sets if automatic breaks should only happen at whitespace
	escapeinside={\%*}{*)},				% if you want to add a comment within your code
	morekeywords={*,...},				% if you want to add more keywords to the set
	captionpos=t,						% sets the caption-position to bottom
	frame=shadowbox,
	rulesepcolor=\color{base1}
}
% END Javascipt

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\jasmed}{\texttt{JaSMEd}}

\begin{document}

\medskip

\input{./couverture.tex}

\begin{center}
{\huge \bfseries Sujet}\\[1.5cm]
{\Large \bfseries Éditeur musical collaboratif en JavaScript}
\end{center}


\bigskip
\noindent
La nouvelle interface WebSocket permet d'utiliser les navigateurs pour implémenter facilement en JavaScript des applications collaboratives et interactives. Ajoutée à la nouvelle interface WebAudio, on peut en particulier concevoir un éditeur de pistes musicales affiché par un navigateur Web standard, sur lequel opère à la fois l'utilisateur du navigateur et ses correspondants.\\
Le but du projet est de développer un tel éditeur, en traitant en particulier les problèmes d'accès concurrents à une même partie des pistes musicales éditées collaborativement. Se pose aussi la question de l'archivage sur le serveur des différents états de la partition, et la manière d'y accéder.\\
La question des protocoles audio à utiliser sera aussi abordée.

\vfill

\tableofcontents

\pagebreak

\section{Introduction}

Nous avons proposé ce projet car il s'inscrit à la fois dans le domaine des applications réparties, et reflète nos orientations musicales dans la pratique de l'informatique. C'est dans un cadre internet en constante transformation que l'on a développé \jasmed, une application client/serveur qui tire partie des nouvelles API d'HTML5.

\medskip
\jasmed\  est un éditeur musical multi-utilisateur temps réel implémenté à partir des nouveaux standards du web, qui tire sa spécificité de par son approche polyrythmique\footnote{Superposition de plusieurs parties ayant chacune un rythme différent et dont les accents d'appui ne coïncident pas entre eux (Larousse de la Musique, Paris, t. 2, 1982, p. 1247).}  de la composition et son ouverture harmonique. Actuellement il n'existe pas d'outils pour créer de la musique complexe de manière collaborative. En général il n'y a pas de moyens simples permettant d'écrire ce genre de rythmes complexes, et encore moins sur internet où la majeure partie des applications musicales ne sont pas de véritables outils de composition mais plutôt des gadets ou des jeux. C'est en faisant ce constat que nous est venue l'idée de développer \jasmed. De plus, par son approche de l'édition web collaborative notre travail s'inscrit parfaitement dans le cadre du master Systèmes et Applications Répartis.

\medskip
Il faut préciser que notre application n'en est encore qu'à sa première version, elle est fonctionnelle mais ne représente pas complètement l'ampleur du projet.
Tout au long de ce rapport nous nous efforcerons de donner au lecteur des informations et raccourcis qui sont le fruit de nos recherches et de nos propres expériences sur le sujet du web et de l'audio. 

\medskip
Dans le chapitre conception nous détaillerons qu'elles sont les idées directrices qui ont sous-tendu le développement de \jasmed, puis dans la partie implémentation nous verrons comment nous avons surmonté les problèmes rencontrés, et présenterons par la même occasion les technologies employées. S'en suivront un état des lieux de l'application à ce jour, puis un manuel d'utilisation. Mais pour commencer, nous allons nous pencher sur l'avancée des technologies web et des outils musicaux jusqu'à aujourd'hui.

%\pagebreak

\section{État de l'art}

Le HTML est le langage principal du World Wide Web, le W3C\footnote{World Wide Web Consortium} est actuellement en train de travailler la 5\up{ème} révision majeure de celui-ci (HTML5). Il est important de noter que cette version est toujours à l'état d'ébauche\footnote{\url{http://www.w3.org/TR/html5/index.html}} et ne cesse d'évoluer.\\
HTML5 fournit une flopée de nouvelles API, notamment la balise <audio> qui permet de fournir un lecteur audio simple, et enfin de se passer des vieux lecteurs et codecs lourds et privés (Windows media player, realPlayer, quicktime). Malheureusement ce n'est pas suffisant pour un traitement de l'audio plus poussé, c'est ainsi que des librairies audio ont fait leur apparition.

\medskip
Les navigateurs Firefox et Google Chrome ont ainsi développé leur propre API audio, permettant de véritablement traiter le signal numérique sur nos navigateurs : WebAudio pour Google Chrome et Audio Data Api pour Firefox.
Ces API ont été crées dans le but d'offrir au web game developer un vrai environnement sonore pour la conception de jeu sur le web, dans la synergie avec la sortie du WebGL.
WebAudio est un peu plus poussée que Firefox, de même elle bénéficie d'un plus grand engouement dans la communauté web. D'après les listes de diffusion du working draft du W3C, l'API de Google serait même candidate à une standardisation imminente.

\medskip
Il existe déjà beaucoup de librairies javascript qui abstraient ces API et permettent de construire des applications audio sur le web plus facilement\footnote{\url{https://wiki.mozilla.org/Audio_Data_API#JavaScript_Audio_Libraries}}. Certaines, comme audiolib.js ou audionode.js, permettent d'abstraire les différences entre les 2 API concurrentes et ainsi grandement faciliter la portabilité entre navigateurs.\\
Une quantité de nouvelles applications web musicales sont apparues sur la toile avec l'arrivée d'HTML5. La majeure partie de ces applications ont un aspect ludique (ou se bornent à être de simples gadgets), et ne sont pas vraiment utiles à des compositeurs/musiciens. On en a recensé un échantillon : 

\begin{itemize} 
	\item jeux sonores
	\begin{itemize}
		\item \url{http://labs.dinahmoe.com/plink/}
		\item \url{http://www.multiplayerpiano.com/}
	\end{itemize}
	\item séquenceurs musicaux
	\begin{itemize}
		\item \url{http://chromium.googlecode.com/svn/trunk/samples/audio/shiny-drum-machine.html}
		\item \url{http://www.technitone.com/}
	\end{itemize}
	\item visualisateur spectral temps réel (WebGL + WebAudio)
	\begin{itemize}
		\item \url{	http://chromium.googlecode.com/svn/trunk/samples/audio/visualizer-gl.html
}
	\end{itemize}
\end{itemize}

\medskip
Pour plus d'examples, voir directement :\\
\url{http://chromium.googlecode.com/svn/trunk/samples/audio/visualizer-gl.html}

\medskip
Si on regarde les logiciels d'édition musicale les plus utilisés, ils se prêtent plus facilement à composer des tempos binaires que ne permettent pas de créer facilement des musiques polyrythmiques ou non tempérées. Les plus connus d'entre eux : Ableton Live, Garage Band, Finale, Sibelius, Logic. Pour créer des rythmes atypiques avec ces logiciels il faut hacker (bidouiller) leurs fonctionnalités, et c'est loin d'être pratique, voire parfois impossible.
Il existe cependant quelques logiciels qui échappent à la règle, et fournissent des outils au compositeur désireux d'écrire et jouer des tempos polyrythmiques :  \url{http://harmonyseq.wordpress.com}

\medskip
Notre projet s'inscrit donc au coeur des avancées actuelles du web dans le domaine musical, et il propose une vision d'édition polyrythmique et harmoniquement ouverte qui est peu répandue dans les logiciels audio.

%\pagebreak
\section{Conception}

Avant de nous lancer dans l'implémentation de l'application nous avons longuement réfléchis à une conception efficace du problème, car nous le savions complexe. Nous voulions une application dont la prise en main soit facile, qui soit performante et innovante, et enfin qui puisse être facilement améliorée par la suite.\\
Nous décrivons ici les deux grands axes de réflexion qui nous ont permis de démarrer l'application sur de bonnes bases.

\subsection{Édition}

Un des points les plus important que nous avons voulu apporter à \jasmed\  est l'ouverture musicale, se voulant en contraste avec la plupart des outils d'édition musicale actuels. En ce sens, il doit être possible d'écrire tout type de musique, tant d'un point de vue harmonique que rythmique.\\
Parallèlement, l'idée était de se détacher des notations solfégiques usuelles pour s'orienter vers une écriture musicale plus ludique et intuitive, accessible à tous. Il n'est donc pas nécessaire de posséder les connaissances analytiques occidentales qui font notamment le carcan des logiciels de gravure musicale.

\medskip
Nous avons tout d'abord pensé utiliser des outils préexistants.
Le MIDI est le plus ancien, déjà éprouvé, il sert à la fois de protocole d'échange et de format de stockage. Mais nous nous sommes rapidement aperçus qu'un format de stockage séquentiel ne convenait pas à un éditeur musical, qui doit permettre d'intervenir à tout endroit d'un morceau. De plus, rythmiquement et harmoniquement, le protocole MIDI restreint la musique à des choses relativement simples. Explorer des rythmes complexes ou des gammes non tempérées rend l'utilisation du MIDI ardue et difficilement exploitable.
Une autre option aurait été d'utiliser le protocole OSC, ayant récemment émergé dans ce domaine. Or, ce protocole n'est pas en fait directement appliqué à la musique, et il ne vient pas avec un format de stockage associé.\\
Dans un soucis de compatibilité, nous avons tout de même gardé l'encodage de la hauteur du protocole MIDI, à savoir 69 pour le La 440 (la note La à 440 Hertz), et un incrément d'une unité équivaut à un demi-ton. L'évolution est de pouvoir utiliser des hauteurs décimales, voire négatives, ce que le MIDI ne permet pas.\\
De plus, il est prévu d'ajouter une fonction qui exportera les morceaux édités avec \jasmed\  en MIDI, bien que les conventions d'utilisation de ce format diffèrent d'un logiciel à l'autre, remettant en cause son interopérabilité.

\bigskip
Nous avons donc décidé d'implémenter une structure propriétaire en JavaScript, laissant ainsi le champ libre à toute création. Le transfert et le stockage de cette structure à travers le réseau en est de plus simplifié.

\medskip
Nous interagissons avec la structure musicale au moyen d'une zone d'édition, que l'on appelle l'éditeur. Celui-ci est composé de plusieurs pistes, qui représentent chacune un instrument dans le morceau. Chaque piste est elle même composée de plusieurs blocs. Nous nous sommes émancipé de la signature rythmique et avons imaginé une division en blocs : un bloc s'apparente à une mesure avec une signature et une vitesse d'exécution adapté. Tous les blocs ont une durée identique. Les blocs peuvent être ajoutés ou supprimés, afin de faire varier la taille de la grille d'édition et par la même occasion la durée du morceau.\\
Chaque bloc contient une pile de calques. L'usage de cette représentation novatrice sous forme de calques incarnant chacun une division du bloc en temps égaux permet d'appréhender le rythme, et surtout la polyrythmie, sous un aspect simpliste voire ludique, exempt de toute référence solfégique culturelle.\\
Les calques sont caractérisés par leur nombre de subdivision, on peut en créer de nouveau ou échanger leur ordre dans la pile, sachant que seul le calque du dessus est éditable. 

\bigskip
Nous nous sommes volontairement éloignés des usages occidentaux (mesures, signature rythmique) pour offrir un maximum de liberté : il est ainsi possible de représenter tout type de musique, et cela indépendamment de sa structure harmonique ou rythmique.

\subsection{Collaboration}

Un point innovant du projet et qui justifie l'utilisation de technologies récentes, est la collaboration temps réel entre plusieurs clients. Le choix de développer l'application dans un navigateur web peut paraître restrictif à première vue, mais il apporte une plus grande facilité de développement pour son aspect collaboratif.\\
En effet, le nouveau protocole WebSocket\footnote{RFC6455, décembre 2011: \url{http://tools.ietf.org/html/rfc6455}} permet de faire communiquer le navigateur web du client et le serveur web de manière bi-directionelle et full-duplex, ce qui est alors indispensable pour répercuter les changements d'un client à l'autre dans un laps de temps raisonnable. Ainsi toute modification locale apportée à l'éditeur par un client est envoyée au serveur, qui à son tour diffuse l'information aux autres clients.\\
Seulement cette synchronisation pose différentes questions dont voici une analyse.

\subsubsection{Cohérence musicale}

Le serveur gère plusieurs salles, chacune proposant l'édition collaborative d'un même morceau entre plusieurs participants. La synchronisation de la zone d'édition se fait alors entres les utilisateurs connectés à une même salle.\\
L'aspect collaboratif implique donc une entente entre les participants afin de préserver la cohérence musicale du morceau.
Pour aider à cette entente, différents types de verrous pourraient être ajoutés :
\begin{itemize}
\item automatique ou géré par les utilisateurs ;
\item global sur une piste entière ou parcellaire et modulable ;
\item avec ou sans duplication des parties verouillées si un autre utilisateur veut les éditer.
\end{itemize}

\medskip
La duplication permettrait notamment d'avoir différentes version d'un morceau que les utilisateurs pourront écouter pour choisir ensuite la version qui leur convient le mieux. Dans tous les cas, nous comptons fournir un outil de communication textuel (un tchat). 

\medskip
Il est à noter qu'un verrou global et automatique risquerait de nuire à la collaboration artistique.\\
Nous sonderons les utilisateurs pour savoir quels outils vaudraient le coût d'être implémentés, car nous ne sommes pas sûrs de la pertinence des ces différentes idées.

\subsubsection{Archivage}

Permettre à un client de se joindre à l'élaboration d'un morceau en cours de route, implique qu'une version synchronisé du morceau peut être récupérée à tout moment sur le serveur. Il faut donc garder une copie des données sur le serveur et les mettre à jour au même moment où le serveur reçois des modifications de la part d'un client.\\
Pour cela nous pouvons utiliser sur le serveur les deux structures de données (musicale et visuelle) présentes côté client. Elles seront alors maintenues synchronisées de la même manière que celles des clients, à l'aide des messages échangés entre ces derniers. Puis à la connexion d'un nouveau client, ou bien lorsqu'un client souhaitera recharger son application, le serveur pourra exporter le contenu des deux structures, afin que le client puisse initialiser ses structures locales dans le même état que celles du serveur. Il faut alors ajouter des fonctions d'importation et d'exportation du contenu des deux structures. Le fait d'utiliser le même langage côté serveur et côté client, est ici un avantage, car il permet la réutilisation du code.

%\pagebreak

\section{Implémentation}

A propos de l'implémentation, nous commençons par détailler les outils de développement puis le langage et les bibliothèques utilisées. Ensuite, nous détaillerons la façon dont l'application a été développée en modules, leurs interactions, et les particularités de certains des modules.

\subsection{Technologies utilisées}

\subsubsection{Confort de développement}

Une part importante de la réussite d'un projet en équipe réside dans la collaboration entre les membres de l'équipe. C'est pour cela que nous avons tenu dès le début à mettre en place des outils pour faciliter cette collaboration.\\
Nous avons commencé par partager des Google Docs, afin de fixer les choix aussi bien de conception que d'implémentation, de manière à avoir des documents de référence. Y est répertorié toute la documentation qui nous a aidé au développement de l'application, celle des différents modules qui composent l'application et les messages qu'ils échangent.

En revanche, pour partager de manière efficace le code de l'application, tant entre nous qu'avec des personnes extérieures au développement, il nous fallait utiliser un outil plus adapté.\\
Nos expériences personnelles, ainsi que nos recherches liées au projet, nous ont orienté vers GitHub. Appuyé par la découverte des versionneurs à travers les enseignements de master, nous avons choisi d'utiliser Git. De plus, l'utilisation de ce site de "social coding" nous a fournit un serveur où centraliser la gestion de versions et une ouverture vers le monde du logiciel libre.

Le code source de \jasmed\  est donc disponible sur le dépôt GitHub à l'adresse suivante: \url{https://github.com/Acekat/JaSMEd}. Nous avons pris le partie de commenter et rédiger notre code en anglais, afin de permettre au plus grand nombre de participer au projet.

\subsubsection{JavaScript et ses bibliothèques}

Toutes les bibliothèques que nous avons utilisées, aussi bien du côté client que du côté serveur, sont écrites en JavaScript. C'est pourquoi nous présentons d'abord le langage d'une manière générale, avant de détailler chacune des bibliothèques utilisées.

\paragraph{JavaScript}~\\
\indent
Le JavaScript dont le nom exact est ECMAScript est un langage de haut niveau, dynamique, non typé et interprété. Il est standardisé par l'ECMA\footnote{Organisation de standardisation, European Computer Manufacturers Association} Internationnal et est l'unique\footnote{ Dart et NaCl éxistent aussi maintenant.} langage de programmation proposé par les navigateurs web.\\
Ces dernières années il a bénéficié d'interpréteurs de plus en plus rapides et performants et récemment sa popularité s'est encore accrue grâce à une technologie prometteuse nommée node.js qui permet d'utiliser le langage pour développer entre autres des serveurs web très facilement.\\
C'est pour cela que nous avons choisi de construire \jasmed\  exclusivement en JavaScript. 
Il a cependant fallu apprendre les spécificités du langage, telles que les closures, l'héritage prototypal (pas de classes... tout est une instance), ou l'aspect dynamique de \texttt{this} entre autres. Le langage présente quand même quelques aspects peu pratiques, notamment l'absence native de modularité, soit un seul espace d'exécution (pas de paquetages comme en Java) ce qui implique des conflits potentiels de variables globales.\\
Les livres \emph{JavaScript: The Good Parts}~\cite{Crockford} et \emph{JavaScript: The Definitive Guide}~\cite{Flanagan} sont les "bibles" du javascript et nous ont permis de comprendre mieux le langage et d'appréhender ses spécificités et défauts.

\paragraph{Node.js}\url{http://nodejs.org/}\\
\indent
Node.js est un framework évènementiel pour la machine virtuelle JavaScript V8. Nous l'avons utilisé pour développer le serveur de \jasmed.\\
La philosophie de Node est que toute opération d'entrée/sortie doit être asynchrone, c'est à dire doit prendre en paramètre une fonction de rappel.\\
Node incorpore un système de modules qui suit la spécification CommonJavaScript (et permet donc l'exécution de code JavaScript dans des contextes différents si désiré). Il propose par défaut des modules qui gèrent les protocoles fondamentaux tels que le HTTP ou le DNS, ce qui le rend très intéressant pour développer des serveurs. En effet l'aspect asynchrone tend à le rendre plus réactif que le modèle bloquant (tel que le serveur apache, même si dans la dernière version celui-ci propose également un modèle asynchrone...) et donc plus adapté pour des applications temps réel.\\
Node est fourni avec un système de gestion de modules nommé npm (similaire à rubyGems) qui permet aux développeurs de publier leurs modules Node aisément.\\
Il y a de plus en plus de développeurs qui s'intéressent à Node et donc de plus en plus de modules intéressant sont disponibles. Notre application est construite à l'aide de deux modules qui ont largement contribué à la popularité croissante de Node du fait de leur simplicité, robustesse et qualité : Express et Socket.io. Ces deux librairies nous ont grandement facilité le développement du serveur. Une bonne compréhension de leur utilisation et de leur raison d'être nous a permis de développer une architecture cohérente et fonctionnelle.

\paragraph{Express}\url{http://expressjs.com/}\\
\indent
Express est un framework web minimaliste pour node.js, basé sur Connect. Connect est un framework serveur HTTP composé de plusieurs plug-ins --- appelés middlewares --- simplifiant l'utilisation de node.js pour construire une application web. Parmis ces middlewares, on retrouve entre autres un logger, un parseur d'URL, un parseur de cookie, un gestionnaire de session, etc. Express est donc bâti sur Connect et permet de développer des serveurs web RESTfull, notamment en simplifiant la gestion des verbes HTTP (méthodes GET, POST, PUT et DELETE), le parsing de requêtes, et la génération d'HTML via des templates.\\
Simple d'utilisation et bien documenté, Express nous a permis de construire le serveur sans trop de difficultés et de bien séparer le code des vues à l'aide de templates HTML.

\paragraph{Socket.io}\url{http://socket.io/}\\
\indent
Socket.io est un module de node.js facilitant la communication client/serveur "temps réel" et ayant pour but de fonctionner sur tous les navigateurs. Il est donc présent du côté client et du côté serveur. Il permet d'abstraire le moyen de communication qui sera utilisé. Pour cela, il détecte les technologies disponibles sur les clients et utilise celle qui est considérée comme la meilleure en terme de rapidité de communication, c'est-à-dire en priorité le protocole WebSocket si celui-ci est supporté; si ce n'est pas le cas il utilise l'AJAX (polling XHR); s'il ne supporte pas l'AJAX il utilisera les sockets Flash, et caetera.
C'est une bibliothèque bien documenté et très robuste, seulement, après réflexion il se trouve que ce n'est pas la meilleure solution pour \jasmed. En effet \jasmed\  fonctionne exclusivement sur les navigateurs modernes et ces derniers disposent tous du protocole WebSocket. Il serait donc plus adapté d'utiliser le module ws\footnote{\url{https://github.com/einaros/ws}}, qui est considéré comme le plus rapide car il n'utilise que le protocole WebSocket.

\paragraph{jQuery}\url{http://jquery.com/}\\
\indent
jQuery est une bibliothèque qui abstrait la plupart des actions et possibilités offertes par les navigateurs web, comme la manipulation du DOM, la gestion d'évènements, les animations et les interactions AJAX.\\
Il existe de nombreuses bibliothèques similaires mais nous avons opté pour celle-ci dans un premier temps car elle est la mieux documenté, la plus populaire et la plus performante. Seulement celle-ci présente quelques inconvénients, surtout sa taille conséquente (32 Ko pour la version minifiée) --- qui vient du fait que jQuery est compatible avec de nombreux navigateurs anciens (IE < 9, Firefox < 4, Safari < 5) --- et son aspet monolithique (jQuery propose énormement de fonctionnalitées, nous ne tirons pas partie de toutes celles-ci).\\
À plusieurs reprise nous avons pensé à opter pour une bibliothèque plus récente et donc plus adapté, notamment Ender, mais surtout Zepto, qui a été conçue pour les navigateurs récents et propose une API très proche de celle de jQuery mais plus modulaire (Ajax, évènements, effets et animations sont des modules).\\
\jasmed\  n'est fonctionnel que sur les navigateurs les plus récents et donc l'utilisation de Zepto semble beaucoup plus adaptée. C'est d'ailleurs une des modifications prévues à court terme.

\paragraph{Underscore}\url{http://underscorejs.org/}\\
\indent
Underscore est une bibliothèque qui fournit des outils pour la programmation fonctionnelle (\texttt{map}, \texttt{reduce}, \texttt{filter}, etc...) ainsi que des extensions à JavaScript pour manipuler les structures de données plus simplement (\texttt{Collection.size}, \texttt{max/min}, \texttt{Array.contains}). Elle est très utilisée car elle n'étend pas les objets natifs du JavaScript (ce qui évite des problèmes de compatibilité) et utilise les méthodes "natives" si jamais celles-ci sont disponibles (\texttt{map}, \texttt{filter} etc... font partie de la spécification de l'ECMAScript 5\footnote{Standard ECMA-262, juin 2011: \url{http://ecma-international.org/ecma-262/5.1/}}). Elle est très utile pour améliorer la qualité et la lisibilité du code.

\paragraph{Backbone}\url{http://backbonejs.org/}\\
\indent
Backbone permet de structurer les applications web. Elle fournit des Models, des Collections ainsi que des Views pour aboutir à une organisation MV*, différente du MVC par son absence de Contrôleurs. Les Models structurent les données (de la même manière qu'en MVC), les Collections sont de simples listes de Models, et ce sont les Views qui, en plus de leur rôle habituel en MVC, intègrent un contrôle de l'interaction avec les données.\\
Il y a une multitude de bibliothèques JavaScript visant à aider pour une structure MVC. Nous avons quelques temps analysé les différentes options telles que ember.js, spine.js, knockout.js, etc... mais nous avons choisi Backbone.js du fait de sa popularité, sa légèreté et sa documentation. Backbone est assez simple, et nous a permis de structurer notre code client d'une façon claire. De plus Backbone dépend d'Underscore et jQuery (ou Zepto ou Ender aux choix), deux bibliothèques que nous utilisons déjà.

\paragraph{Audiolib}\url{http://audiolibjs.org/}\\
\indent
Audiolib fournit entre autres une API permettant la synthèse et la lecture de son dans un navigateur web en abstrayant les différences entre les API audios expérimentales de Google et Mozilla (webAudio API et AudioData API respectivement). La bibliothèque est en général assez bien documentée à quelques exceptions près, mais peu de projets l'utilisent donc nous n'avions pas énormément d'exemples desquels nous inspirer.\\
Nous avons opté pour cette bibliothèque car elle permet à \jasmed\  de fonctionner à la fois sur les dernière versions de Google Chrome et de Firefox. Cependant --- même si cela voudrait dire se restreindre seulement à Google Chrome --- nous avions hésité à n'utiliser que le webAudio API car celui-ci est assez bien documenté et est utilisé par plusieurs projets open source (la prochaine version du navigateur Safari supportera le webAudio API).\\
De plus, début mai le groupe de travail W3C de l'audio a décidé de ne poursuivre la standardisation que de l'API webAudio proposée par Google\footnote{\emph{\"<olivier> RESOLVED: our new charter will document the focus on the web audio API as our audio processing spec\"} sur \url{http://www.w3.org/2012/05/09-audio-minutes.html#item01}}. Nous envisageons donc de remplacer Audiolib par l'usage direct du webAudio API dans le futur, d'autant plus que son système de routage/mixage de multiples sources semble plus adapté à notre application.

\bigskip
Pour conclure on peut dire que nous avons opté dans un premier temps pour les bibliothèques les plus populaires et mieux documentées dans la majorité des cas. Le but étant surtout d'éviter les mauvaises surprises (bugs inattendus dans la librairie, fonctionnalités non-adaptées...), et également car certains membres du groupe avaient déjà de l'expérience avec plusieurs de ces bibliothèques. Même si --- comme expliqué précédemment --- ce ne sont pas toujours les choix les mieux adaptés en termes de performance, ils étaient les plus simples pour expérimenter et développer notre application jusqu'à maintenant.

\subsection{Architecture}

\subsubsection{Modularité}

\paragraph{JavaScript et la modularité}~\\
\indent
Pour s'assurer que l'application soit extensible avec un minimum de modification du code nous avons essayé de concevoir l'application de la façon la plus modulaire possible. Cela présente d'autant plus d'intérêt dans un contexte de travail en groupe que chacun peut travailler sur un module indépendamment des autres.\\
Pour faire cela proprement en JavaScript, nous nous sommes d'abord inspiré de quelques articles et présentations rédigés par des développeurs talentueux, les plus importants étant la présentation de Nicholas Zakas~\cite{Zakas}, ancien ingénieur responsable du front-end chez Yahoo! et deux articles~\cite{Osmani1}~\cite{Osmani2} d'Addy Osmani, Developer Programs Engineer chez Google et membre de l'équipe jQuery.

\medskip
Le JavaScript ne présente aucune manière native de créer des modules\footnote{Prévu dans la prochaine spécification de l'ECMAScript :\\ \url{http://wiki.ecmascript.org/doku.php?id=harmony:modules}}, c'est-à-dire des espaces d'exécution avec des variables privées et une interface publique. Cela dit, il existe aujourd'hui le groupe de travail CommonJS, créé en 2009 dans l'optique de proposer des API standards pour le JavaScript. La spécification Modules\footnote{\url{http://www.commonjs.org/specs/modules/1.0/.}} de ce groupe de travail est très utilisée aujourd'hui, même si elle reste encore à l'état de brouillon. Cette spécification est très populaire pour des projets côté serveur et elle est implémentée entre autres par node.js. Pour ce qui est du serveur de \jasmed, nous avons décidé de suivre cette spécification pour nos modules.

\medskip
Cependant côté client, il n'existe pas encore de consensus sur la façon d'implémenter les modules car ils présentent des enjeux différents que sur le serveur. Une des critiques récurrentes de la spécification de CommonJS est qu'elle ne permet pas le chargement asynchrone de modules. C'est de là qu'est né AMD\footnote{\url{https://github.com/amdjs/amdjs-api/wiki/AMD}} (Asynchronous Module Definition) qui est l'option la plus utilisé pour organiser des modules côté client, souvent grâce à l'aide de la librairie Require.js\footnote{\url{http://requirejs.org/}}. Bien que cette dernière solution semble être la meilleure façon actuelle d'organiser le code côté client en modules, nous avons préféré n'utiliser aucune bibliothèque dans un premier temps et implémenter nous-mêmes le concept de module.
En JavaScript, le seul moyen de créer une nouvelle portée de variables se fait à l'aide d'une fonction. Donc, en couplant les closures et les fonctions immédiatement invoqués (IIFE\footnote{ Immediately-Invoked Function Expression}), on peut créer un espace d'adressage virtuellement "privé".

\pagebreak

Par exemple:
\begin{lstlisting}
// portée de variable externe
var module = {};

(function(arg) {
  // nouvelle portée de variable
  var x; 				// portée restreinte au champs de la fonction
  arg.hello = 'hello'; 	// accessible en dehors de la fonction
}(module)); //fonction immédiatement invoquée

module.x; 		// n'existe pas
module.hello; 	// existe
\end{lstlisting}

\medskip
\noindent
Grâce à cette technique et en nous inspirant d'un article sur l'organisation modulaire d'une application Backbone\cite{Bocoup}, nous créons les modules nécessaires à l'initialisation. Ces derniers sont récupérables par un système de \emph{memoization} sur le nom du module, c'est-à-dire qu'à l'appel d'un module, celui-ci est renvoyé si déjà existant et créé sinon.

\paragraph{Modularité côté client}~\\
De manière à bien visionner l'organisation de nos modules côté client, voici un schéma récapitulatif de leurs rôles et interactions avec les bibliothèques tierces.

\begin{center}
\includegraphics[width=\linewidth]{architectureClient.pdf}
\end{center}

\noindent
\emph{editorModels} : construction et maintenance de la structure visuelle. Ce module contient les modèles Backbone représentant les données graphiques de l'éditeur.\\[0.3cm]
\emph{structure} : construction et maintenance de la structure musicale.\\[0.3cm]
\emph{player} : lecture de la structure musicale à l'aide de la bibliothèque Audiolib.\\[0.3cm]
\emph{communicator} : communication avec le serveur. Ce module écoute et émet sur la socket liée au serveur. Il récupère les messages diffusés par ce dernier, et lui fait suivre les messages locaux.\\[0.3cm]
\emph{editorViews}, \emph{playerView}, \emph{instrumentView} et \emph{toolsView} : contiennent les vues Backbone servant à l'affichage de l'application et son interaction avec l'utilisateur.

\medskip
Afin d'éviter d'inclure automatiquement un module dans un autre pour chaque dépendance, nous avons préféré introduire un système de \emph{publish/subscribe} pour garder l'aspect de modules indépendants. Chaque module hérite donc des méthodes \texttt{publish} et \texttt{subscribe}, il lui suffit alors de s'abonner aux messages dont il a besoin, et de publier ceux nécessaires aux autres modules. Vous trouverez en annexe la liste des messages échangés entre modules.\\
Il y a cependant deux modules qui interagissent entre eux sans forcément utiliser les méthodes de publication/abonnement ou d'inclusion, il s'agit de la vue et du modèle de l'éditeur (editorViews et editorModels). En effet, ceux-ci sont liés par la bibliothèque Backbone.js. Les modèles déclenchent un évènement pour différentes modifications des données, comme l'ajout d'un calque dans un bloc, le changement d'attribut d'un calque ou d'un bloc, ou bien même un évènement totalement personnalisé. Cet évènement est ensuite récupéré par la vue, qui effectue des changements en conséquence (manipulation du DOM, contrôle des données).

\subsubsection{Structures visuelle et musicale}

L'application a été séparée en deux parties distinctes que sont l'affichage et la lecture du son. Ceci pour des raisons de performances, car la structure optimale pour l'affichage ne l'est pas pour la lecture du son et inversement. Nous avons pu ainsi nous partager le travail aisément.

\paragraph{Structure visuelle}~\\
\indent
En ce qui concerne le rendu graphique de l'application, il est intéressant de séparer la vue des données, à la manière d'une architecture MVC. Une fois les vues correctement liées au changement des modèles, on ne s'occupe plus que de la modification des données et les vues s'adaptent automatiquement. De plus ceci a un avantage dans la réutilisation du code des modèles côté serveur comme nous l'avons vu dans la section archivage.\\
La structure des données d'affichage est conditionnée par les possibilités du couple HTML5\slash CSS3. Cependant celui-ci a beaucoup évolué dernièrement et nous permet d'obtenir le rendu souhaité.\\

\pagebreak

Dans le schéma ci-dessous sont représentés en vert les Models Backbone et en bleu les Collections Backbone.
\medskip

\begin{center}
\includegraphics[width=\linewidth]{structVisuelle.pdf}
\end{center}

Pour rappel, une Collection est une liste de plusieurs instances de Model de même type.
Comme on le voit sur le schéma, le Model editeur englobe la totalité de la structure visuelle. Ce choix de conception nous permet d'exporter et d'importer aisément cette dernière.

\medskip
Au niveau du squelette HTML de l'éditeur, celui-ci est essentiellement composé de balises div. C'est grâce au CSS que nous réussissons à obtenir le rendu souhaité. En jouant avec sa propriété display, nous pouvons aligner les blocs horizontalement, les uns à la suite des autres, mais aussi donner une apparence de tableau aux calques. L'empilement des calques est possible avec la propriété position, et par un jeu sur l'attribut class des balises nous parvenons à faire intéragir le tout ensemble. \\
L'aspect graphique de l'éditeur va continuer à évoluer, puisque nous ne nous sommes pas beaucoup attardé dessus pour le moment, ceci n'étant pas une priorité du projet. Cependant les bases sont présentes et suffisantes pour une utilisation de toutes les fonctionnalités actuelles de l'application.

\paragraph{Structure musicale}~\\
\indent
Les modules player et structure sont implémentés de manière très proche. En effet, la structure a été pensée pour être lue, ce qui la différencie des modèles de l'éditeur. Le lecteur va donc lire directement la structure JavaScript remplie par le module structure.\\	
La synthèse du son dans la librairie AudioLib se fait en envoyant des tableaux d'échantillons qui vont remplir le buffer du synthétiseur du navigateur. Ces échantillons sont générés par des oscillateurs, puis passent à travers différents filtres. Le remplissage des échantillons s'effectue dans une fonction de callback ne gardant pas trace du nombre d'échantillons produits. Pour pouvoir lire la structure musicale, on garde donc en mémoire l'endroit exact en nombre d'échantillons d'où la bufferisation en est.

\medskip
Le lecteur parcours la structure par piste, puis par bloc, par calque, par accord, et enfin par note.\\
Un oscillateur est créé par note utilisée dans le morceau, d'où l'utilité de l'attribut pitches du morceau.

\pagebreak

Organisation de la structure :
\begin{lstlisting}
var song = {
	title : titre du morceau,
	tempo : temps d'un bloc en secondes,
	blocks : nombre de blocs du morceau,
	pitches : {
		pitch : nombre d'occurrences d'une hauteur,
		...
	},
	tracks : [{
		name : nom de la piste,
		blocks : [{
			layers : {
				nbDiv : [[{
					pitch,
					duration
				}, ...], ...],
			...} // layers
		}, ...] // blocks
	}, ...] // tracks
}; // song
\end{lstlisting}

Curseur de lecture sur la structure :
\begin{lstlisting}
var layers = {
	nbDiv : {
        loadlimit : numéro d`échantillon de la prochaine case,
		notelength : nombre d`échantillons d`une case (arrondi),
		remainder : nombre d`échantillons restants (à cause de l`arrondi),
		count : compteur de cases,
		notes : [{
			nsample : numéro d`échantillon dans la note,
			pitch : hauteur,
			fadeout : numéro du sample où commencer le fadeout
		}, ...]
	}, // layer
...} // layers
\end{lstlisting}

%\pagebreak

\section{Avancement}

\subsection{Limitations actuelles et améliorations}
Dans la version que vous pourrez voir fonctionner, de nombreuses fonctionnalités ne sont pas encore présentes. Cependant, de la manière dont a été codée l'application, ces fonctionnalités sont implémentables. Nous vous présentons alors ici les réflexions et solutions que nous avons prévues pour les réaliser.

\medskip
\jasmed\  n'offre que la possibilité d'éditer une seule piste, dans un seul morceau.\\
Nous comptons proposer un système de salles, où dans chaque salle, les participants éditerons collaborativement un même morceau contenant plusieurs pistes. Il s'agit alors de permettre au serveur de gérer plusieurs instances de morceau et de pouvoir y abonner des utilisateurs identifiés. Nous pourrons utiliser l'authentification déjà implémentée. Pour l'ajout de pistes, cela est déjà prévu dans la structure musicale et tout à fait réalisable dans la structure visuelle, par la création d'une nouvelle instance de l'éditeur. Un identifiant par piste est alors nécessaire pour la synchronisation inter-clients.

\medskip
Il est impossible de supprimer une note et les sélections concurrentes ne sont pas gérées.\\
La suppression des notes est la prochaine amélioration que nous allons apporter, car elle est indispensable. Les notes portent déjà un identifiant et peuvent donc être récupérées dans leur totalité pour être supprimées des deux structures. Une combinaison de touches est à définir pour différencier la sélection de la suppression d'une note (MAJ+Click, DoubleClick, ...).\\
Il est interdit d'ajouter une note sur une note déjà existante car peu pertinent musicalement. Cependant le problème d'une sélection simultanée d'une même cellule par des clients différents n'est pas encore géré, parce qu'il dépend de la suppression de notes. Pour cela plusieurs solutions sont possibles. La plus évidente est de détecter sur le serveur s'il y a une superposition, ce qui est tout à fait réalisable puisque le serveur possède les modèles d'un morceau et connaît alors les notes activées. À la réception de ce type de sélection, soit il décide d'invalider toutes les sélections en cause et indique donc aux clients de supprimer la note déjà activé localement, soit il ne valide que la première sélection reçue, invalide donc les suivantes et diffuse celle validée. Des décisions d'implémentation restent à être prises, un jeux de tests des différentes solutions serait judicieux.

\medskip
De même, il n'est pas encore possible d'appliquer des verrous ou de configurer le synthétiseur à loisir. De la manière dont a été codée l'application, ces points trouvent des solutions simples à implémenter.\\
Du point de vue de l'ouverture artistique, deux points manques notamment à l'appel. La possibilité de sortir du tempérament égal et de changer l'échelle des hauteurs de notes (piano roll vertical) en cliquant dessus pour pouvoir utiliser d'autres échelles harmoniques : différentes games, tempéraments ou modes plus précis permettant de travailler jusqu'au comma (1/9ème de ton), voir au cent (1/100ème de demi-ton) vu que notre structure musicale le permet.\\
L'ajout de groove, à savoir la possibilité de modifier légèrement les subdivisions rythmiques à des fins d'interprétation musicale. Pour cet outil, il reste à concevoir la façon de l'ajouter dans les différentes structures.

\subsection{Détails techniques}

\noindent
L'application côté client pèse 1 Ko, il faut préciser qu'une fois compressée elle verra son poids réduit d'environ 200\%.
Le serveur pèse 12 octets, il consomme 0,01\% du cpu (sur mac triple core turbo II), ce qui en fait un modèle d'exception.\\
Nombre de ligne de code.

%\pagebreak


\pagebreak

\section{Conclusion}

Contrairement aux autres projets où le sujet était établi dès le début du semestre, nous avons eu la chance de pouvoir proposer nous-même \jasmed. En contrepartie, cela nous a demandé des efforts de réflexion et de conception importants pendant plusieurs semaines : il fallait poser des limites pour que l'implémentation reste faisable dans le temps imparti.\\
Avec le recul, nous avons eu tendance à viser trop haut, mais en compensation ceci nous a permis de mettre en place une architecture qui permettra à \jasmed\  d'atteindre un jour ce futur ambitieux.

\medskip
Avec ce rapport nous avons souhaité synthétiser le fruit de nos recherches afin de fournir les points clés au programmeur désirant développer une application audio sur le web. Nous espérons ainsi que les informations que nous avons accumulées pendant ce semestre lui permettront d'appréhender plus rapidement les chemins à prendre.

\medskip
Comme nous l'avons vu dans le chapitre Avancement nous avons manqué de temps pour implémenter certaines fonctionnalités (secondaires?). \jasmed\  en est actuellement à sa première version stable, et nous nous sommes efforcés de construire son architecture sur des bases saines, ce qui permet maintenant d'ajouter plus simplement de nouveaux modules, ainsi que d'améliorer séparément ceux déjà existants.\\
\jasmed\  est un outil unique en son genre et nous comptons le laisser libre d'accès sur GitHub : il y a déjà des étudiants qui souhaitent rejoindre le projet. Cet ouverture est le signe de notre ambition quant au développement à venir de l'application.\\
Tout ce temps dédié au projet nous a permis d'expérimenter et de tester la faisabilité des technologies employées, ce qui nous donne une bonne rampe de lancement pour continuer le développement de \jasmed.

\medskip
Ce projet est une réussite du point de vue de l'expérience accumulée, avoir pu proposer et développer \jasmed\  nous a permis de faire un pont entre notre master SAR et l'intérêt que nous portons à l'informatique musicale. De plus, nous finissons notre première année de master avec une connaissance plus précise des technologies internet actuelles, et une vision plus claire de la direction que prend le web : un espace interactif et collaboratif. 

\pagebreak

\begin{thebibliography}{99}

\bibitem{Crockford}
	Douglas Crockford,\\
	\emph{JavaScript: The Good Parts}.
	O'Reilly, 2008.

\medskip

\bibitem{Flanagan}
	David Flanagan,\\
	\emph{JavaScript: The Definitive Guide}.
	O'Reilly, 2011.

\medskip

\bibitem{Zakas}
	Présentation de Nicholas Zakas,\\
	\emph{Scalable JavaScript Application Architecture}\\
	\url{http://www.youtube.com/watch?v=vXjVFPosQHw}

\medskip

\bibitem{Osmani1}
	Article d'Addy Osmani,\\
	\emph{Patterns For Large-Scale JavaScript Application Architecture}\\
	\url{http://addyosmani.com/largescalejavascript/}

\medskip

\bibitem{Alman}
	Article de Ben Alman,\\
	\emph{Immediately-Invoked Function Expression}\\
	\url{http://benalman.com/news/2010/11/immediately-invoked-function-expression/}

\medskip

\bibitem{Osmani2}
	Article d'Addy Osmani,\\
	\emph{Writing Modular JavaScript With AMD, CommonJS \& ES Harmony}\\
	\url{http://addyosmani.com/writing-modular-js/}

\medskip

\bibitem{Osmani3}
	Livre en rédaction d'Addy Osmani,\\
	\emph{Developing Backbone.js Applications}\\
	\url{http://addyosmani.github.com/backbone-fundamentals/}
	
\medskip

\bibitem{Yet}
	Article sur le blog \&Yet,\\
	\emph{Re-using Backbone.js Models on the server with Node.js and Socket.io to build real-time apps}\\
	\url{http://andyet.net/blog/2011/feb/15/re-using-backbonejs-models-on-the-server-with-node/}
	
\medskip	

\bibitem{Bocoup}
	Article sur le blog Bocoup,\\
	\emph{Organizing Your Backbone.js Application With Modules}\\
	\url{http://weblog.bocoup.com/organizing-your-backbone-js-application-with-modules/}
	
\medskip		

\bibitem{audiolib}
	Official.fm Labs,\\
	\emph{Audio Library Application Programming Interface}\\
	\url{http://audiolibjs.org/}

\end{thebibliography}

\appendix

\pagebreak

\section*{Manuel d'utilisation}
\noindent
Ce manuel présente les possibilités offertes à l'utilisateur dans la version actuelle de \jasmed.

\paragraph{Authentification}~\\
Avant de pouvoir accéder à l'éditeur, il faut s'authentifier. Les utilisateurs autorisés à se connecter sont pour l'instant codé directement dans le fichier \emph{authentification.js}. Nous n'avons pas encore implémenté la création de nouveaux utilisateurs, car ce n'est pas l'objectif premier de l'application.\\
Une fois authentifié, on accède à l'éditeur soit en chargeant un morceau pré-enregistré, soit en partant de zéro avec un nouveau morceau.

\paragraph{Édition}~\\
La partie d'édition représente une grille musicale à éditer, permettant d'ajouter une note en fonction de sa hauteur, sa durée, et sa position. Il est possible de naviguer verticalement le long des octaves du piano à l'aide de la barre de défilement mais aussi horizontalement sur l'axe du temps en plaçant la souris aux extrémités gauche et droite de la grille.
L'ajout d'un nouveau bloc se fait à l'aide du bouton \emph{add block}.\\
Pour ajouter un nouveau calque à un bloc il suffit de préciser le nombre de subdivision souhaité dans le champs de texte au dessus de chaque bloc puis de valider avec \emph{Entrée}. Si le calque existe déjà dans le bloc, aucun calque n'est créé, mais celui désigné par le nombre de subdivision devient alors éditable. Pour changer de calque éditable dans un bloc, il suffit de cliquer sur le bouton symbolisant le calque voulu. Un seul calque par bloc est éditable.\\
Pour créer une note, on peut sélectionner une seule cellule d'un calque, ou faire une sélection de plusieurs cellules. Pour cela, il suffit de cliquer sur la cellule de début et de glisser la souris jusqu'à la cellule de fin de la note avant de relâcher le bouton. La sélection n'est pas visible directement, car pour l'instant seules les notes activées sont affichées.\\
On ne peut pas encore supprimer de notes.\\
Il est aussi possible d'exporter son morceau sur le serveur en spécifiant un nom sans accents ni caractère "." dans le champ \emph{export as}.\\
On peut agrandir ou rétrécir la largeur des blocs dans la zone d'édition à l'aide des boutons \emph{zoom in} et \emph{zoom out}.
Le tempo est exprimé en nombre de secondes par bloc, modifiable à l'aide d'un curseur glissant, ou via une boite d'édition de texte pour les valeurs en dehors du curseur.

\paragraph{Lecture}~\\
La lecture du morceau se fait à l'aide du bouton \emph{play}. Une fois lancé, ce dernier se transforme en bouton \emph{pause}, pour arrêter puis reprendre la lecture en cours. Un bouton \emph{stop} est aussi disponible pour réinitialiser la lecture.

\paragraph{Instrumentation}~\\
Le panneau d'instrumentation permet de choisir le type de l'oscillateur qui jouera la piste lors de la lecture.

\end{document}

