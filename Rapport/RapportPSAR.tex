\documentclass[pdftex,12pt,a4paper]{article}

\usepackage[french]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage[final]{pdfpages}
\usepackage{fullpage}
\usepackage{setspace}

\usepackage{url}
\usepackage{graphicx}

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\jasmed}{\texttt{JaSMEd}}

\begin{document}

\input{./couverture.tex}


\begin{center}
{\huge \bfseries Sujet}\\[1.5cm]
\end{center}
{\Large \bfseries Editeur musical collaboratif en JavaScript}

\bigskip
La nouvelle interface WebSocket permet d’utiliser les navigateurs pour implémenter facilement en JavaScript des applications collaboratives et interactives. Ajoutée à la nouvelle interface WebAudio, on peut en particulier concevoir un éditeur de pistes musicales affiché par un navigateur Web standard, sur lequel opère à la fois l’utilisateur du navigateur et ses correspondants.\\
Le but du projet est de développer un tel éditeur, en traitant en particulier les problèmes d’accès concurrents à une même partie des pistes musicales éditées collaborativement. Se pose aussi la question de l’archivage sur le serveur des différents états de la partition, et la manière d’y accéder.\\
La question des protocoles audio à utiliser sera aussi abordée.

\vfill

\pagebreak

\tableofcontents

\pagebreak

\section{Introduction}

\section{État de l'art}


\section{Conception}

Avant de nous lancer dans l’implémentation de l’application nous avons longuement réfléchis à une conception efficace du problème car nous le savions complexe. Nous voulions une application dont la prise en main soit facile, qui soit performante et innovante, et enfin qui puisse être facilement améliorée par la suite.\\
Nous décrivons ici les trois grands axes de réflexion qui nous ont permis de démarrer l’application sur de bonnes bases.

\subsection{Structures}

\subsubsection{Musicale}

\subsubsection{Visuelle}

\subsection{Collaboration}

Un point innovant du projet et qui justifie l’utilisation de technologies récentes, est la collaboration temps réel entre plusieurs client. Le choix de développer l’application dans un navigateur web peut paraître restrictif à première vue, mais il apporte une plus grande facilité de développement pour son aspect collaboratif.\\
En effet, le nouveau protocole WebSocket\footnote{RFC6455, décembre 2011: \url{http://tools.ietf.org/html/rfc6455}} permet de faire communiquer le navigateur web du client et le serveur web de manière bi-directionnelle et full-duplex, ce qui est alors indispensable pour répercuter les changements d’un client à l’autre dans un lapse de temps raisonnable. Ainsi toute modification locale apportée à l’éditeur par un client est envoyée au serveur, qui à son tour broadcast l’information aux autres clients.\\
Seulement cette synchronisation introduit différents problèmes dont voici une analyse.

\subsubsection{Concurrence}

\subsubsection{Archivage}

Permettre à un client de se joindre à l’élaboration d’un morceau en cours de route, implique qu’une version synchronisé du morceau peut être récupérée à tout moment sur le serveur. Il faut donc garder une copie des données sur le serveur et les mettre à jour au même moment où le serveur reçois des modifications de la part d’un client.\\
Pour cela nous pouvons utiliser sur le serveur les deux structures de données (musicale et visuelle) présentes côté client. Elles seront alors maintenues synchronisées de la même manière que celles des clients, à l’aide des messages échangés entre ces derniers. Puis à la connexion d’un nouveau client, ou bien lorsqu’un client souhaitera recharger son application, le serveur pourra exporter le contenu des deux structures, afin que le client puisse initialiser ses structures locales dans le même état que celles du serveur. Il faut alors ajouter des fonctions d’importation et d’exportation du contenu des deux structures. Le fait d’utiliser le même langage côté serveur et côté client, est ici un avantage, car il permet la réutilisation du code.

\subsection{Modularité}


\section{Implémentation}

\subsection{Technologies utilisées}

\subsubsection{Confort de développement}

Une part importante de la réussite d’un projet en équipe réside dans la collaboration entre les membres de l’équipe. C’est pour cela que nous avons tenu dès le début à mettre en place des outils pour faciliter cette collaboration.\\
Nous avons commencé par partager des Google Docs, afin de fixer les choix aussi bien de conception que d’implémentation, de manière à avoir des documents de référence. Y est répertorié toute la documentation qui nous a aidé au développement de l’application, mais aussi les différents modules qui composent l’application et les messages échangés entre eux.\\
Ensuite, durant notre documentation, nous avons remarqué que beaucoup de projets open-source que nous utilisons ont un dépôt GitHub pour faire participer la communauté au développement. C’est alors un moyen facile pour nous de mettre en commun le développement de l’application, dans un premier temps entre les membres de l’équipe du projet, mais aussi par la suite à toute autre personne souhaitant participer au projet.\\
Nous avons alors découvert Git pour la gestion des versions en local, qui s’avère être un outils presque indispensable dans le développement d’une application telle que JaSMEd.\\
Le code source de JaSMEd est donc disponible sur le dépôt GitHub à l’adresse suivante: \url{https://github.com/Acekat/JaSMEd}. Nous avons pris le partie de commenter et rédiger notre code en anglais, afin de permettre au plus grand nombre de participer au projet.

\subsubsection{JavaScript et ses bibliothèques}

Toutes les bibliothèques que nous avons utilisées, aussi bien du côté client que du côté serveur, sont écrites en JavaScript. C’est pourquoi nous présentons d’abord le langage d’une manière générale, avant de détailler chacune des bibliothèques utilisées.

\paragraph{JavaScript}~\\
Le JavaScript (JS) dont le nom exact est ECMAScript est un langage de haut niveau, dynamique, non typé et interprété. Il est standardisé par l’ECMA Internationnal et est l’unique\footnote{Dart et NaCl éxistent aussi maintenant.} langage de programmation proposé par les navigateurs web.\\
Ces dernières années il a bénéficié d’interpréteurs de plus en plus rapides et performants et récemment sa popularité s’est encore accrue grâce à une technologie prometteuse nommée node.js qui permet d’utiliser le langage pour développer entre autres des serveurs web très facilement.\\
C’est pour cela que nous avons choisi de construire JaSMEd exclusivement en JavaScript.

\medskip
Il a cependant fallu apprendre les spécificités du langage, telles que les closures, l’héritage prototypal (pas de classes... tout est une instance), ou l’aspect dynamique de \texttt{this} entre autres. Le langage présente quand même quelques peu pratiques, notamment le fait qu’il n’y ait pas de modularité nativement, soit un seul espace d’exécution (pas de paquetage comme en Java) ce qui implique des conflits potentiels de variables globales.\\
Les livres \emph{JavaScript: The Good Parts}~\cite{Crockford} et \emph{JavaScript: The Definitive Guide}~\cite{Flanagan} sont les “bibles” du javascript et nous ont permis de comprendre mieux le langage et d’appréhender ses spécificités et les défauts.

\paragraph{Node.js}\url{http://nodejs.org/}\\
Node.js est un framework évènementiel pour la machine virtuelle JavaScript V8. Nous l’avons utilisé pour développer le serveur de JaSMEd.
La philosophie de Node est que toute opération d’entrée/sortie doit être asynchrone, c’est à dire doit prendre en paramètre une fonction de rappel.\\
Node incorpore un système de module qui suit la spécification CommonJS (et permet donc l'exécution de code JS dans des contextes différents si désiré). Il propose par défaut des modules qui gèrent les protocoles fondamentaux tels que le HTTP ou le DNS ce qui le rend très intéressant pour développer des serveurs. En effet l’aspect asynchrone tend à le rendre plus réactif que le modèle bloquant (tel que le serveur apache, même si dans la dernière version celui-ci propose également un modèle asynchrone...) et donc plus adapté pour des applications temps réel.\\
Node est fourni avec un système de gestion de module nommé npm (similaire à rubyGems) qui permet aux développeurs de publier leurs modules node aisément.\\
Il y a de plus en plus de développeurs qui s’intéressent à Node et donc de plus en plus de modules intéressant sont disponibles. Notre application est construite à l’aide de deux modules qui ont largement contribué à la popularité croissante de node du fait de leurs simplicité, robustesse et qualités: Express et Socket.io.

\paragraph{Express}\url{http://expressjs.com/}

\paragraph{Socket.io}\url{http://socket.io/}\\
Socket.io est un module de node.js facilitant la communication client/serveur “tempsréel” et ayant pour but de fonctionner sur tous les navigateurs. Il est donc présent du côté client et du côté serveur. Il permet d’abstraire le moyen de communication qui sera utilisé. Pour cela, il détecte les technologies disponibles sur les clients et utilise celle qui est considérée comme la meilleure en rapidité de communication. C’est-à-dire en priorité le protocole WebSocket si celui-ci est supporté; si ce n’est pas le cas il utilise l’AJAX (polling XHR); si il ne supporte pas l’AJAX il utilisera les sockets Flash, et caetera.\\
C’est une bibliothèque bien documenté et très robuste seulement, après réflexion il se trouve que ce n’est pas la meilleure solution pour JaSMEd. En effet JaSMEd fonctionne exclusivement sur les navigateurs modernes et ces derniers disposent tous du protocole WebSocket. Il serait donc plus adapté d’utiliser le module ws, qui est considéré comme le plus rapide car il n’utilise que le protocole WebSocket.

\paragraph{jQuery}\url{http://jquery.com/}\\
jQuery est une bibliothèque qui abstrait la plupart des actions/possibilités offertes par les navigateurs web comme la manipulation du DOM, la gestion d’évènements, les animations et les interactions AJAX.\\
Il existe de nombreuses bibliothèques similaires mais nous avons opté pour celle-ci dans un premier temps car elle est la mieux documenté, la plus populaire et la plus performante. Seulement celle-ci présente quelques inconvénients, surtout sa taille conséquente (32 Ko pour la version minifiée) — qui vient du fait que jQuery est compatible avec nombreux navigateurs anciens (IE < 9, Firefox < 4, Safari < 5) — et son aspet monolithique (jQuery propose énormement de fonctionnalitées, nous ne tirons pas partie de toutes celles-ci).\\
À plusieurs reprise nous avons pensé à opter pour une bibliothèque plus récente et donc plus adapté. Notamment Ender mais surtout Zepto, qui a été conçue pour les navigateurs récents et propose une API très proche de celle de jQuery mais plus modulaire (Ajax, évènements, effets/animations sont des modules).\\
JaSMEd n’est fonctionnel que sur les navigateurs les plus récents et donc l’utilisation de Zepto semble beaucoup plus adaptée. C’est d'ailleurs une des modifications prévues à court terme.

\paragraph{Underscore}\url{http://documentcloud.github.com/underscore/}\\
Underscore est une bibliothèque qui fournit des outils pour la programmation fonctionnelle (\texttt{map}, \texttt{reduce}, \texttt{filter}, etc...) ainsi que des extensions à JS pour manipuler les structures de données plus simplement (\texttt{Collection.size}, \texttt{max/min}, \texttt{Array.contains}). Elle est très utilisé car elle n’étend pas les objets natifs du JS (ce qui évite des problèmes de compatibilité) et utilise les méthodes ‘natives’ si jamais celles-ci sont disponibles (map, filter etc... font partie de la spécification de l’ECMAScript 5\footnote{Standard ECMA-262, juin 2011: \url{http://ecma-international.org/ecma-262/5.1/}}). Elle est très utile pour améliorer la qualité et la lisibilité du code.

\paragraph{Backbone}\url{http://documentcloud.github.com/backbone/}\\
Backbone permet de structurer les applications web. Elle fournit des \texttt{Model}, des \texttt{Collection} ainsi que des \texttt{View} pour aboutir à une organisation MV*, différente du MVC dans son absence de Contrôleur à part entière. Les \texttt{Model} structurent les données (de la même manière qu’en MVC), les \texttt{Collection} sont de simples listes de \texttt{Model}, et ce sont les \texttt{View} qui, en plus de leur rôle habituel en MVC, intègre un contrôle de l’intéraction avec les données.\\
Il y a une multitude de bibliothèques JS visant à aider à une structure MVC. Nous avons quelques temps analysés les différentes options telles que ember.js, spine.js, knockout.js, etc... mais nous avons choisi Backbone.js du fait de sa popularité, sa légèreté et sa documentation. Backbone est assez simple, et nous a permis de structurer notre code client d’une façon claire. De plus Backbone dépend d’Underscore et jQuery (ou Zepto ou Ender aux choix), deux bibliothèques que nous utilisons déjà.

\paragraph{Audiolib}\url{https://github.com/jussi-kalliokoski/audiolib.js}\\
Audiolib fournit entre-autres une API permettant la synthèse et la lecture de son dans un navigateur web en abstrayant les différences entre les API audio expérimentaux de Google et Mozilla (webAudio API et AudioData API respectivement).
Nous avons opté pour cette bibilothèque car elle permet que JaSMEd fonctionne à la fois sur les dernière versions de Google Chrome et de Firefox.
La bibliothèque est en général assez bien documenté à quelques exceptions près mais peu de projets l’utilise, donc nous n’avions pas énormément d’exemples pour nous inspirer. Son utilisation n’était donc pas toujours évidente.
Cependant, même si  nous avions hésiter à n’utiliser que le webAudio API car celui-ci est assez bien documenté et est utilisé par plusieurs projets open source. (la prochaine version du navigateur Safari supportera le webAudio API)
De plus, début Mai (link: http://www.w3.org/2012/05/09-audio-minutes.html), le groupe de travail W3C de l’audio a décidé de ne poursuivre la standardisation que de l’API webAudio proposé par Google. Nous envisageons donc de remplacer Audiolib par l’usage direct du webAudio API dans le futur, d’autant plus que son système de routage/mixage de multiples sources semble plus adapté à notre application.

\subsection{Architecture}


\section{Avancement}

\subsection{Limitations actuelles de l’application}

\subsection{Détails techniques}


\section{Manuel d'utilisation}

\subsection{Édition}

\subsection{Lecture}

\subsection{Outils}

\subsection{Instrumentation}


\section{Conclusion}

\pagebreak

\begin{thebibliography}{99}

\bibitem{Crockford}
	Douglas Crockford,
	\emph{JavaScript: The Good Parts}.
	O'Reilly, 2008.

\medskip

\bibitem{Flanagan}
	David Flanagan,
	\emph{JavaScript: The Definitive Guide}.
	O'Reilly, 2011.

\medskip

\bibitem{audiolib}
	Jussi Kalliokosky,
	\emph{Audio Library Application Programming Interface}.\\
	\url{https://github.com/jussi-kalliokoski/audiolib.js}

\end{thebibliography}

\appendix

\end{document}

pb et difficultés:
-MIDI (chap conception)
-largeur de bloc ->affichage non-cohérent, curseur de lecture
-sample décalage
-app scalable -> modulaire/gestion centralisé, MV*
-latence d'initialisation lecture