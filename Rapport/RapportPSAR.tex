\documentclass[12pt,a4paper]{article}

\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[french]{babel}

\usepackage[final]{pdfpages}
\usepackage{fullpage}
\usepackage{setspace}

\usepackage{url}
\usepackage{graphicx}

% BEGIN Javascipt
\usepackage{listings}
\usepackage{color}
% Solarized
\definecolor{base03}{RGB}{0,43,54}		% brblack
\definecolor{base02}{RGB}{7,54,66}		% black
\definecolor{base01}{RGB}{88,110,117}	% brgreen
\definecolor{base00}{RGB}{101,123,131}	% bryellow
\definecolor{base0}{RGB}{131,148,150}	% brblue
\definecolor{base1}{RGB}{147,161,161}	% brcyan
\definecolor{base2}{RGB}{238,232,213}	% white
\definecolor{base3}{RGB}{253,246,227}	% brwhite
\definecolor{yellow}{RGB}{181,137,0}	% yellow
\definecolor{orange}{RGB}{203,75,22}	% brred
\definecolor{red}{RGB}{220,50,47}		% red
\definecolor{magenta}{RGB}{211,54,130}	% magenta
\definecolor{violet}{RGB}{108,113,196}	% brmagenta
\definecolor{blue}{RGB}{38,139,210}		% blue
\definecolor{cyan}{RGB}{42,161,152}		% cyan
\definecolor{green}{RGB}{133,153,0}		% green

\lstdefinelanguage{JavaScript}{
	keywords=[1]{typeof, return, export, implements, import, try, catch, throw, if, else, for, in, while, do, switch, case, break},
	keywords=[2]{function, class, new, var, boolean, this},
	keywords=[3]{null, true, false, undefined},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	morestring=[b]',
	morestring=[b]"
}

\lstdefinestyle{SolarizedLight}{
	language=Javascript,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=[1]\color{yellow}\bfseries,
	keywordstyle=[2]\color{blue}\bfseries,
	keywordstyle=[3]\color{orange}\bfseries,
	commentstyle=\color{base0},
	stringstyle=\color{cyan},
	backgroundcolor=\color{base3}
}

\lstset{
	language=Javascript,				% language of the code
	style=SolarizedLight,				% style of the code
	% numbers=left,						% where to put the line-numbers
	% numberstyle=\tiny\color{gray},	% the style that is used for the line-numbers
	% stepnumber=2,						% the step between two line-numbers. If it's 1, each line will be numbered
	% numbersep=5pt,					% how far the line-numbers are from the code
	showspaces=false,					% show spaces adding particular underscores
	showstringspaces=false,				% underline spaces within strings
	showtabs=false,						% show tabs within strings adding particular underscores
	tabsize=2,							% sets default tabsize to 2 spaces
	breaklines=true,					% sets automatic line breaking
	breakatwhitespace=false,			% sets if automatic breaks should only happen at whitespace
	escapeinside={\%*}{*)},				% if you want to add a comment within your code
	morekeywords={*,...},				% if you want to add more keywords to the set
	captionpos=t,						% sets the caption-position to bottom
	frame=shadowbox,
	rulesepcolor=\color{base1}
}
% END Javascipt

\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\newcommand{\jasmed}{\texttt{JaSMEd}}

\begin{document}

\medskip

\input{./couverture.tex}

\begin{center}
{\huge \bfseries Sujet}\\[1.5cm]
\end{center}
{\Large \bfseries Éditeur musical collaboratif en JavaScript}

\bigskip
La nouvelle interface WebSocket permet d'utiliser les navigateurs pour implémenter facilement en JavaScript des applications collaboratives et interactives. Ajoutée à la nouvelle interface WebAudio, on peut en particulier concevoir un éditeur de pistes musicales affiché par un navigateur Web standard, sur lequel opère à la fois l'utilisateur du navigateur et ses correspondants.\\
Le but du projet est de développer un tel éditeur, en traitant en particulier les problèmes d'accès concurrents à une même partie des pistes musicales éditées collaborativement. Se pose aussi la question de l'archivage sur le serveur des différents états de la partition, et la manière d'y accéder.\\
La question des protocoles audio à utiliser sera aussi abordée.

\vfill

\tableofcontents

\pagebreak


\section{Introduction}

Nous avons proposé ce projet car il s'inscrit à la fois dans le domaine des applications réparties, et reflète nos orientations musicales dans la pratique de l'informatique. C'est dans un cadre internet en constante transformation que l'on a développé JaSMEd, une application client/serveur qui tire partie des nouvelles API d'HTML5.

\medskip
JaSMEd est un éditeur musical multi-utilisateur temps réel implémenté à partir des nouveaux standards du web qui tire sa spécificité de par son approche de composition polyrythmique\footnote{Superposition de plusieurs parties ayant chacune un rythme différent et dont les accents d'appui ne coïncident pas entre eux (Larousse de la Musique, Paris, t. 2, 1982, p. 1247).} et son ouverture harmonique. Actuellement il n'existe pas d'outils pour créer des musiques complexes de manière collaborative. En général il n'y a pas de moyens simples permettant d'écrire ce genre de rythmes complexes, et encore moins sur internet où la majeure partie des applications musicales ne sont pas de véritables outils de composition. C'est en faisant ce constat que nous est apparue l'idée de développer JaSMEd. De plus, par son approche de l'édition web collaborative notre travail s'inscrit parfaitement dans le cadre du master Systèmes et Applications Répartis.\\

\medskip
Il faut préciser que notre application n'est encore qu'à sa première version, elle est fonctionnelle mais ne représente pas encore complètement l'ampleur du projet.\\
Tout au long de ce rapport nous nous efforcerons de donner au lecteur des informations et raccourcis qui sont le fruit de nos recherches et de nos propres expériences sur le sujet du web et de l'audio.

\medskip
Dans le chapitre conception nous détaillerons qu'elles sont idées directrices qui ont sous-tendu le développement de Jasmed, alors que dans la partie implémentation nous verrons comment nous avons surmonté ces problèmes, et présenterons par la même occasion les technologies employées.


\section{État de l'art}

Le HTML est le langage principal du World Wide Web, le W3C\footnote{World Wide Web Consortium} est actuellement en train de travailler la 5\up{ème} révision majeure de celui-ci (HTML5). Il est important de noter que cette version est toujours à l'état d'ébauche\footnote{\url{http://www.w3.org/TR/html5/index.html}} et ne cesse d'évoluer.\\
HTML5 fournit une flopée de nouvelles API, notamment la balise <audio> qui permet de fournir un lecteur audio simple, et enfin de se passer des vieux lecteurs et codecs lourds et privés (Windows media player, realPlayer, quicktime). Malheureusement ce n'est pas suffisant pour un traitement de l'audio plus poussé, c'est ainsi que des librairies audio ont fait leur apparition.

\medskip
Les navigateurs Firefox et Google Chrome ont ainsi développé leur propre API audio, permettant de véritablement traiter le signal numérique sur nos navigateurs : WebAudio pour Google Chrome et Audio Data Api pour Firefox.\\
Ces API ont été crées dans le but d'offrir au web game developer un vrai environnement sonore pour la conception de jeu sur le web, dans la synergie avec la sortie du WebGL.\\
WebAudio est un peu plus poussée que Firefox, de même elle bénéficie d'un plus grand engouement dans la communauté web. D'après les listes de diffusion du working draft du W3C, l'API de Google serait même candidate à une standardisation imminente.

\medskip
Il existe déjà beaucoup de librairies javascript qui abstraient ces API et permettent de construire des applications audio sur le web plus facilement\footnote{\url{https://wiki.mozilla.org/Audio_Data_API#JavaScript_Audio_Libraries}}. Certaines, comme audiolib.js ou audionode.js, permettent d'abstraire les différences entre les 2 API concurrentes et ainsi grandement faciliter la portabilité entre navigateurs.\\
Une quantité de nouvelles applications web musicales sont apparues sur la toile avec l'arrivée d'HTML5. La majeure partie de ces applications ont un aspect ludique (ou se bornent à être de simples gadgets), et ne sont pas vraiment utiles à des compositeurs/musiciens. On en a recensé un échantillon :
\begin{itemize} 
	\item jeux sonores
	\item séquenceurs musicaux\\
\url{http://chromium.googlecode.com/svn/trunk/samples/audio/shiny-drum-machine.html}
\url{http://www.technitone.com/#}
	\item visualisateur spectral temps réel (WebGL + WebAudio)\\
\url{http://chromium.googlecode.com/svn/trunk/samples/audio/visualizer-gl.html}
\end{itemize}

\medskip
Si on regarde les logiciels d'édition musicale les plus utilisés, ils se prêtent plus facilement à composer des tempos binaires que ne permettent pas de créer facilement des musiques polyrythmiques ou non tempérées. Les plus connus d'entre eux : Ableton Live, Garage Band, Finale, Sibelius, Logic. Pour créer des rythmes atypiques avec ces logiciels il faut hacker (bidouiller) leurs fonctionnalités, et c'est loin d'être pratique, voire parfois impossible.\\
Il existe cependant quelques logiciels qui échappent à la règle, et fournissent des outils au compositeur désireux d'écrire et jouer des tempos polyrythmiques : \url{http://harmonyseq.wordpress.com}

\medskip
Notre projet s'inscrit donc au coeur des avancées actuelles du web dans le domaine musical, et il propose une vision d'édition polyrythmique et harmoniquement ouverte qui est peu répandue dans les logiciels audio.


\section{Conception}

Avant de nous lancer dans l'implémentation de l'application nous avons longuement réfléchis à une conception efficace du problème, car nous le savions complexe. Nous voulions une application dont la prise en main soit facile, qui soit performante et innovante, et enfin qui puisse être facilement améliorée par la suite.\\
Nous décrivons ici les trois grands axes de réflexion qui nous ont permis de démarrer l'application sur de bonnes bases.

\subsection{Édition}

Un des points les plus important que nous avons voulu apporter à JaSMEd est l'ouverture musicale, se voulant contrastante avec la plupart des outils d'édition musicale actuels. En ce sens, il doit être possible d'écrire tout type de musique, tant d'un point de vue harmonique que rythmique.\\
Parallèlement, l'idée était de se détacher des notations solfégiques usuelles pour s'orienter vers une écriture musicale plus ludique et intuitive, accessible à tous, sans posséder les connaissances analytiques occidentales qui font notamment le carcan des logiciels de gravure musicale.

\bigskip
Pour plus de facilitées, nous avons tout d'abord pensé à utiliser des outils préexistants.\\
Le MIDI est le plus ancien, déjà éprouvé, il sert à la fois de protocole d'échange et de format de stockage. Mais nous nous sommes rapidement aperçus qu'un format de stockage séquentiel ne convenait pas à un éditeur musical, permettant lui d'intervenir à tout endroit d'un morceau. De plus, rythmiquement et harmoniquement, le protocole MIDI restreint la musique à des choses relativement simples. Explorer des rythmes complexes ou des gammes non tempérées rend l'utilisation du MIDI ardue et difficilement exploitable.\\
Une autre option aurait été d'utiliser le protocole OSC, ayant récemment émergé dans ce domaine. Or, ce protocole n'est pas en fait directement appliqué à la musique, et il ne vient pas avec un format de stockage associé.\\
Dans un soucis de compatibilité, nous avons tout de même gardé l'encodage de la hauteur du protocole MIDI, à savoir 69 pour le La 440, et un incrément équivaut à un demi-ton. L'évolution est de pouvoir utiliser des hauteurs décimales, voire négatives, ce que le MIDI ne permet pas.\\
De plus, il est prévu d'ajouter une fonction qui exportera les morceaux édités avec Jasmed en MIDI, bien que les conventions d'utilisation de ce format diffèrent d'un logiciel à l'autre, remettant en cause son interopérabilité.\\
Nous avons donc décidé d'implémenter une structure propriétaire en JS, laissant ainsi le champ libre à toute création. Le transfert et le stockage de cette structure à travers le réseau en est de plus simplifié.

\medskip
Nous interagissons avec la structure musicale au moyen d'une zone d'édition, que l'on appelle l'éditeur. Celui-ci est composé de plusieurs pistes, qui représentent chacune un instrument dans le morceau. Chaque piste est elle même composée de plusieurs blocs. Nous nous sommes émancipé de la signature rythmique et avons imaginé une division en blocs : un bloc s'apparente à une mesure avec une signature et une vitesse d'exécution adapté. Tous les blocs ont une durée identique. Les blocs peuvent être ajoutés ou supprimés, afin de faire varier la taille de la grille d'édition et par la même occasion la durée du morceau.\\
Chaque bloc contient une pile de calques. L'usage de cette représentation novatrice sous forme de calques incarnant chacun une division du bloc en temps égaux permet d'appréhender le rythme, et surtout la polyrythmie, sous un aspect simpliste voire ludique, exempt de toute référence solfégique culturelle.\\
Les calques sont caractérisés par leur nombre de subdivision égales, on peut en créer de nouveau ou échanger leur ordre dans la pile, sachant que seul le calque du dessus est éditable. 

\bigskip
De cette manière, il est ainsi possible de représenter tout type de musique rythmique, quelque soit sa structure. Nous nous sommes volontairement éloignés des usages occidentaux (mesures, signature rythmique) pour offrir un maximum de liberté.
Afin de permettre des écarts vers des divisions inégales, principalement à des fins d'interprétation musicale, la création d'un outil approprié est envisagée.

\subsection{Collaboration}

Un point innovant du projet et qui justifie l'utilisation de technologies récentes, est la collaboration temps réel entre plusieurs clients. Le choix de développer l'application dans un navigateur web peut paraître restrictif à première vue, mais il apporte une plus grande facilité de développement pour son aspect collaboratif.\\
En effet, le nouveau protocole WebSocket\footnote{RFC6455, décembre 2011: \url{http://tools.ietf.org/html/rfc6455}} permet de faire communiquer le navigateur web du client et le serveur web de manière bi-directionelle et full-duplex, ce qui est alors indispensable pour répercuter les changements d'un client à l'autre dans un laps de temps raisonnable. Ainsi toute modification locale apportée à l'éditeur par un client est envoyée au serveur, qui à son tour diffuse l'information aux autres clients.\\
Seulement cette synchronisation introduit différents problèmes dont voici une analyse.

\subsubsection{Cohérence musicale}

\subsubsection{Archivage}

Permettre à un client de se joindre à l'élaboration d'un morceau en cours de route, implique qu'une version synchronisé du morceau peut être récupérée à tout moment sur le serveur. Il faut donc garder une copie des données sur le serveur et les mettre à jour au même moment où le serveur reçois des modifications de la part d'un client.\\
Pour cela nous pouvons utiliser sur le serveur les deux structures de données (musicale et visuelle) présentes côté client. Elles seront alors maintenues synchronisées de la même manière que celles des clients, à l'aide des messages échangés entre ces derniers. Puis à la connexion d'un nouveau client, ou bien lorsqu'un client souhaitera recharger son application, le serveur pourra exporter le contenu des deux structures, afin que le client puisse initialiser ses structures locales dans le même état que celles du serveur. Il faut alors ajouter des fonctions d'importation et d'exportation du contenu des deux structures. Le fait d'utiliser le même langage côté serveur et côté client, est ici un avantage, car il permet la réutilisation du code.


\section{Implémentation}

\subsection{Technologies utilisées}

\subsubsection{Confort de développement}

Une part importante de la réussite d'un projet en équipe réside dans la collaboration entre les membres de l'équipe. C'est pour cela que nous avons tenu dès le début à mettre en place des outils pour faciliter cette collaboration.\\
Nous avons commencé par partager des Google Docs, afin de fixer les choix aussi bien de conception que d'implémentation, de manière à avoir des documents de référence. Y est répertorié toute la documentation qui nous a aidé au développement de l'application, mais aussi les différents modules qui composent l'application et les messages échangés entre eux.\\
Ensuite, durant notre documentation, nous avons remarqué que beaucoup de projets open-source que nous utilisons ont un dépôt GitHub pour faire participer la communauté au développement. C'est alors un moyen facile pour nous de mettre en commun le développement de l'application, dans un premier temps entre les membres de l'équipe du projet, mais aussi par la suite à toute autre personne souhaitant participer au projet.\\
Nous avons alors découvert Git pour la gestion des versions en local, qui s'avère être un outils presque indispensable dans le développement d'une application telle que JaSMEd.\\
Le code source de JaSMEd est donc disponible sur le dépôt GitHub à l'adresse suivante: \url{https://github.com/Acekat/JaSMEd}. Nous avons pris le partie de commenter et rédiger notre code en anglais, afin de permettre au plus grand nombre de participer au projet.

\subsubsection{JavaScript et ses bibliothèques}

Toutes les bibliothèques que nous avons utilisées, aussi bien du côté client que du côté serveur, sont écrites en JavaScript. C'est pourquoi nous présentons d'abord le langage d'une manière générale, avant de détailler chacune des bibliothèques utilisées.

\paragraph{JavaScript}~\\
Le JavaScript (JS) dont le nom exact est ECMAScript est un langage de haut niveau, dynamique, non typé et interprété. Il est standardisé par l'ECMA Internationnal et est l'unique\footnote{Dart et NaCl éxistent aussi maintenant.} langage de programmation proposé par les navigateurs web.\\
Ces dernières années il a bénéficié d'interpréteurs de plus en plus rapides et performants et récemment sa popularité s'est encore accrue grâce à une technologie prometteuse nommée node.js qui permet d'utiliser le langage pour développer entre autres des serveurs web très facilement.\\
C'est pour cela que nous avons choisi de construire JaSMEd exclusivement en JavaScript. 
Il a cependant fallu apprendre les spécificités du langage, telles que les closures, l'héritage prototypal (pas de classes... tout est une instance), ou l'aspect dynamique de \texttt{this} entre autres. Le langage présente quand même quelques aspects peu pratiques, notamment l'absence native de modularité, soit un seul espace d'exécution (pas de paquetage comme en Java) ce qui implique des conflits potentiels de variables globales.\\
Les livres \emph{JavaScript: The Good Parts}~\cite{Crockford} et \emph{JavaScript: The Definitive Guide}~\cite{Flanagan} sont les "bibles" du javascript et nous ont permis de comprendre mieux le langage et d'appréhender ses spécificités et défauts.

\paragraph{Node.js}\url{http://nodejs.org/}\\
Node.js est un framework évènementiel pour la machine virtuelle JavaScript V8. Nous l'avons utilisé pour développer le serveur de JaSMEd.
La philosophie de Node est que toute opération d'entrée/sortie doit être asynchrone, c'est à dire doit prendre en paramètre une fonction de rappel.\\
Node incorpore un système de module qui suit la spécification CommonJS (et permet donc l'exécution de code JS dans des contextes différents si désiré). Il propose par défaut des modules qui gèrent les protocoles fondamentaux tels que le HTTP ou le DNS, ce qui le rend très intéressant pour développer des serveurs. En effet l'aspect asynchrone tend à le rendre plus réactif que le modèle bloquant (tel que le serveur apache, même si dans la dernière version celui-ci propose également un modèle asynchrone...) et donc plus adapté pour des applications temps réel.\\
Node est fourni avec un système de gestion de module nommé npm (similaire à rubyGems) qui permet aux développeurs de publier leurs modules node aisément.\\
Il y a de plus en plus de développeurs qui s'intéressent à Node et donc de plus en plus de modules intéressant sont disponibles. Notre application est construite à l'aide de deux modules qui ont largement contribué à la popularité croissante de node du fait de leur simplicité, robustesse et qualité : Express et Socket.io.

\paragraph{Express}\url{http://expressjs.com/}\\
Express est un framework web minimaliste pour node.js, basé sur Connect. Connect est un framework serveur HTTP composé de plusieurs plug-ins --- appelés middlewares --- simplifiant l'utilisation de node.js pour construire une application web. Parmis ces middlewares on retrouve entre autres un logger, un parseur d'URL, un parseur de cookie, un gestionnaire de session, etc. Express est donc bâti sur Connect et permet de développer des serveur web RESTfull notamment en simplifiant la gestion des verbes HTTP (méthodes GET, POST, PUT et DELETE), le parsing de requêtes, et la génération d'HTML via des templates.
Simple d'utilisation et bien documenté, Express nous a permis de construire le serveur sans trop de difficultés et de bien séparer le code des vues à l'aide de templates HTML.

\paragraph{Socket.io}\url{http://socket.io/}\\
Socket.io est un module de node.js facilitant la communication client/serveur "temps réel" et ayant pour but de fonctionner sur tous les navigateurs. Il est donc présent du côté client et du côté serveur. Il permet d'abstraire le moyen de communication qui sera utilisé. Pour cela, il détecte les technologies disponibles sur les clients et utilise celle qui est considérée comme la meilleure en terme de rapidité de communication. C'est-à-dire en priorité le protocole WebSocket si celui-ci est supporté; si ce n'est pas le cas il utilise l'AJAX (polling XHR); si il ne supporte pas l'AJAX il utilisera les sockets Flash, et caetera.\\
C'est une bibliothèque bien documenté et très robuste, seulement, après réflexion il se trouve que ce n'est pas la meilleure solution pour JaSMEd. En effet JaSMEd fonctionne exclusivement sur les navigateurs modernes et ces derniers disposent tous du protocole WebSocket. Il serait donc plus adapté d'utiliser le module ws, qui est considéré comme le plus rapide car il n'utilise que le protocole WebSocket.

\paragraph{jQuery}\url{http://jquery.com/}\\
jQuery est une bibliothèque qui abstrait la plupart des actions/possibilités offertes par les navigateurs web comme la manipulation du DOM, la gestion d'évènements, les animations et les interactions AJAX.\\
Il existe de nombreuses bibliothèques similaires mais nous avons opté pour celle-ci dans un premier temps car elle est la mieux documenté, la plus populaire et la plus performante. Seulement celle-ci présente quelques inconvénients, surtout sa taille conséquente (32 Ko pour la version minifiée) --- qui vient du fait que jQuery est compatible avec nombreux navigateurs anciens (IE < 9, Firefox < 4, Safari < 5) --- et son aspet monolithique (jQuery propose énormement de fonctionnalitées, nous ne tirons pas partie de toutes celles-ci).\\
À plusieurs reprise nous avons pensé à opter pour une bibliothèque plus récente et donc plus adapté. Notamment Ender mais surtout Zepto, qui a été conçue pour les navigateurs récents et propose une API très proche de celle de jQuery mais plus modulaire (Ajax, évènements, effets/animations sont des modules).\\
JaSMEd n'est fonctionnel que sur les navigateurs les plus récents et donc l'utilisation de Zepto semble beaucoup plus adaptée. C'est d'ailleurs une des modifications prévues à court terme.

\paragraph{Underscore}\url{http://underscorejs.org/}\\
Underscore est une bibliothèque qui fournit des outils pour la programmation fonctionnelle (\texttt{map}, \texttt{reduce}, \texttt{filter}, etc...) ainsi que des extensions à JS pour manipuler les structures de données plus simplement (\texttt{Collection.size}, \texttt{max/min}, \texttt{Array.contains}). Elle est très utilisé car elle n'étend pas les objets natifs du JS (ce qui évite des problèmes de compatibilité) et utilise les méthodes "natives" si jamais celles-ci sont disponibles (\texttt{map}, \texttt{filter} etc... font partie de la spécification de l'ECMAScript 5\footnote{Standard ECMA-262, juin 2011: \url{http://ecma-international.org/ecma-262/5.1/}}). Elle est très utile pour améliorer la qualité et la lisibilité du code.

\paragraph{Backbone}\url{http://backbonejs.org/}\\
Backbone permet de structurer les applications web. Elle fournit des \texttt{Model}, des \texttt{Collection} ainsi que des \texttt{View} pour aboutir à une organisation MV*, différente du MVC dans son absence de Contrôleur à part entière. Les \texttt{Model} structurent les données (de la même manière qu'en MVC), les \texttt{Collection} sont de simples listes de \texttt{Model}, et ce sont les \texttt{View} qui, en plus de leur rôle habituel en MVC, intègre un contrôle de l'interaction avec les données.\\
Il y a une multitude de bibliothèques JS visant à aider à une structure MVC. Nous avons quelques temps analysés les différentes options telles que ember.js, spine.js, knockout.js, etc... mais nous avons choisi Backbone.js du fait de sa popularité, sa légèreté et sa documentation. Backbone est assez simple, et nous a permis de structurer notre code client d'une façon claire. De plus Backbone dépend d'Underscore et jQuery (ou Zepto ou Ender aux choix), deux bibliothèques que nous utilisons déjà.

\paragraph{Audiolib}\url{http://audiolibjs.org/}\\
Audiolib fournit entre-autres une API permettant la synthèse et la lecture de son dans un navigateur web en abstrayant les différences entre les API audio expérimentaux de Google et Mozilla (webAudio API et AudioData API respectivement). La bibliothèque est en général assez bien documentée à quelques exceptions près mais peu de projets l'utilisent, donc nous n'avions pas énormément d'exemples pour nous inspirer.
Nous avons opté pour cette bibliothèque car elle permet à JaSMEd de fonctionner à la fois sur les dernière versions de Google Chrome et de Firefox. Cependant --- même si cela voudrait dire se restreindre seulement à Google Chrome --- nous avions hésité à n'utiliser que le webAudio API car celui-ci est assez bien documenté et est utilisé par plusieurs projets open source. (la prochaine version du navigateur Safari supportera le webAudio API)
De plus, début mai le groupe de travail W3C de l'audio a décidé de ne poursuivre la standardisation que de l'API webAudio proposé par Google\footnote{\emph{\"<olivier> RESOLVED: our new charter will document the focus on the web audio API as our audio processing spec\"} sur \url{http://www.w3.org/2012/05/09-audio-minutes.html#item01}}. Nous envisageons donc de remplacer Audiolib par l'usage direct du webAudio API dans le futur, d'autant plus que son système de routage/mixage de multiples sources semble plus adapté à notre application.

\bigskip
Pour conclure on peut dire que nous avons opter dans un premier temps pour les bibliothèques les plus populaires et mieux documentés dans la majorité des cas. Le but étant surtout d'éviter les mauvaises surprises (bugs inattendus dans la librairie, fonctionnalités non-adaptées...), et également car certains membres du groupe avaient déjà de l'expérience avec plusieurs de ces bibliothèques. Même si --- comme expliqué précédemment --- ce ne sont pas toujours les choix les mieux adaptés en termes de performance, ils étaient les plus simples/sains pour expérimenter/développer notre application jusqu'à maintenant.

\subsection{Architecture}

\subsubsection{Modularité}

\paragraph{Organisation côté client}~\\
\emph{editorModels}: module de construction et de maintenance de la structure visuelle. Il contient les modèles Backbone représentants les données graphiques de l'éditeur.\\[0.4cm]
\emph{structure}: module de construction et de maintenance de la structure musicale.\\[0.4cm]
\emph{player}: permet la lecture du morceau grâce à la bibliothèque audiolib. Ce module est programmé pour jouer un morceau donc l'information est stocké par la structure exclusivement.\\[0.4cm]
\emph{communicator}: module de communication avec le serveur. Il écoute et émet sur la socket lié au serveur et récupère ainsi les messages broadcastés par ce dernier et lui fait suivre les messages locaux.\\[0.4cm]
\emph{editorViews, playerView, instrumentView et toolsView}: contiennent les vues Backbone servants à l'affichage de l'application et son interaction avec l'utilisateur.

\paragraph{JavaScript et la modularité}~\\
Pour s'assurer que l'application soit extensible avec un minimum de réécriture de code nous avons essayé de concevoir l'application de la façon la plus modulaire possible. Cela présente d'autant plus d'intérêt dans un contexte de travail en groupe car chacun peut travailler sur un module indépendamment des autres.\\
Pour faire cela proprement en JS nous nous sommes d'abord inspiré de quelques articles et présentations rédigés par de talentueux développeurs. Les plus importants étant: la présentation de Nicholas Zakas~\cite{Zakas}, ancien ingénieur responsable du front-end chez Yahoo! et deux articles~\cite{Addy}~\cite{Osmani} d'Addy Osmani, Developer Programs Engineer chez Google et membre de l'équipe jQuery.

\medskip
Le JavaScript ne présente aucune manière native de créer des modules\footnote{Prévu dans la prochaine spécification de l'ECMAScript: \url{http://wiki.ecmascript.org/doku.php?id=harmony:modules}}, c'est-à-dire des espaces d'exécution avec des variables privées et une interface publique. Cela dit il existe aujourd'hui le groupe de travail CommonJS, créé en 2009 dans l'optique de proposer des API standards pour le JS. Une des spécifications à l'état de brouillon, mais très utilisée aujourd'hui, est celle des modules CommonJS\footnote{\url{http://www.commonjs.org/specs/modules/1.0/.}}. Cette spécification est très populaire pour des projets côté serveur et elle est implémentée entre autres par node.js. Pour ce qui est du serveur nous avons décidé de suivre cette spécification pour développer les modules.

\medskip
Cependant côté client, il n'existe pas encore de consensus sur la façon d'implémenter les modules car ils présentent des enjeux différents que sur le serveur. Une des critiques récurrentes de CommonJS est qu'elle ne permet pas le chargement asynchrone de modules. C'est de là qu'est né AMD\footnote{\url{https://github.com/amdjs/amdjs-api/wiki/AMD}} (Asynchronous Module Definition) qui est l'option la plus utilisé pour organiser des modules côté client, souvent grâce à l'aide de la librairie Require.js\footnote{\url{http://requirejs.org/}}. Bien que cette dernière solution semble être la meilleure façon actuelle d'organiser le code côté client en modules, nous avons préféré n'utiliser aucune bibliothèque dans un premier temps et implémenter nous-mêmes le concept de module.
En JavaScript, le seul moyen de créer une nouvelle portée de variables se fait à l'aide d'une fonction. Donc en couplant les closures et les fonctions immédiatement invoqués (IIFE), on peut créer un espace d'adressage virtuellement "privé".\\
Exemple:
\begin{lstlisting}
// portée de variable externe
var module = {};

(function(arg) {
  // nouvelle portée de variable
  var x; 				// portée restreinte au champs de la fonction
  arg.hello = 'hello'; 	// accessible en dehors de la fonction
}(module)); //fonction immédiatement invoquée

module.x; 		// n'existe pas
module.hello; 	// existe
\end{lstlisting}

\medskip
De cette manière là nous pouvons aussi inclure un module dans un autre en cas de dépendance forte.

\paragraph{Communication inter-modules}~\\
Afin d'éviter d'inclure automatiquement un module dans un autre pour chaque dépendance, nous avons préféré introduire un système de \emph{publish/subscribe}, pour garder l'aspect de modules indépendants. Chaque module hérite donc des méthodes \texttt{publish} et \texttt{subscribe}, il lui suffit de s'abonner aux messages dont il a besoin, et de publier ceux nécessaires aux autres modules.\\
Il reste cependant quelques modules qui interagissent entre eux sans forcément utiliser les méthodes de publication/abonnement ou d'inclusion. Il y a la vue et le modèle de l'éditeur, ceux-ci sont liés par la bibliothèque Backbone.js. Les modèles déclenchent un évènement pour différentes modifications des données, comme l'ajout d'un calque dans un bloc, le changement d'attribut d'un calque ou d'un bloc, ou bien même un évènement totalement personnalisé. Cet évènement est ensuite récupéré par la vue, qui effectue des changements en conséquence (manipulation du DOM, contrôle des données). On obtient ainsi une architecture MV* comme décrite dans la conception.

\subsubsection{Structures visuelle et musicale}

L'application a été séparée en deux parties distinctes que sont l'affichage et la lecture du son. Ceci pour des raisons de performances, car la structure optimale pour l'affichage ne l'est pas pour la lecture du son et inversement. Nous avons pu ainsi nous partager le travail aisément.

\paragraph{Structure visuelle}~\\
Pour ce qui concerne le rendu graphique de l'application, il est intéressant de séparer la vue des données, à la manière d'une architecture MVC. Une fois les vues correctement liée au changement des modèles, on ne s'occupe plus que de la modification des données et les vues suivent automatiquement. De plus ceci a un avantage dans la réutilisation du code des modèles côté serveur comme nous l'avons vu dans la section archivage.

\medskip
La structure des données de l'affichage est en quelque sorte conditionnée par les possibilités du couple HTML5/CSS3. Cependant celui-ci a beaucoup évolué dans ses dernières versions respectives, et nous permet d'obtenir le rendu que nous souhaitions.\\
L'éditeur est alors représenté par un Model Backbone, ceci pour pouvoir l'exporter ou l'importer aisément. Ce Model contient une Collection de blocs, qui symbolise la grille d'édition dans sa totalité. Un bloc est un Model de la Collection précédente, il contient toutes les informations relatives à chaque bloc, comme sa largeur ou son ordre dans la grille. Il inclut lui même aussi une Collection qui sont les claques d'un bloc. C'est une Collection de Model calque, où chaque calque est caractérisé par le bloc auquel il appartient et le nombre de subdivision qu'il contient. On y trouve aussi les informations pour savoir si le calque est éditable --- au dessus des autres calques --- ou encore les cellules activées. C'est à travers les calques éditables de chaque bloc que l'on peut faire des sélections de cellules afin d'activer ou désactiver des notes.\\
Au niveau du squelette HTML de l'éditeur, celui-ci est essentiellement composé de de balises div. C'est grâce au CSS que nous réussissons à obtenir le rendu souhaité. En jouant avec a propriété display, nous pouvons aligner les blocs horizontalement, les uns à la suite des autres, mais aussi donner une apparence de tableau aux calques. L'empilement des calques est possible avec la propriété position, et par un jeux sur l'attribut class des balises nous parvenons à faire intéragir le tout ensemble.

\medskip
L'aspect graphique de l'éditeur va continuer à évoluer, puisque nous ne nous sommes pas beaucoup attardé dessus pour le moment, ceci n'étant pas une priorité du projet. Cependant les bases sont présentes et suffisantes pour une utilisation de toutes les fonctionnalités actuelles de l'application.

\paragraph{Structure musicale}~\\
Les modules Lecteur et Structure sont implémentés de manière très proche. En effet, la structure a été pensée pour être lue, et ce qui la différencie des modèles de l'éditeur. Le lecteur va donc lire directement la structure JS remplie par le module Structure.\\
La synthèse du son dans la librairie AudioLib se fait en envoyant des tableaux d'échantillons qui vont remplir le buffer du synthétiseur du navigateur. Ces échantillons sont générés par des oscillateurs, puis passent à travers différents filtres. Le remplissage des échantillons s'effectue dans une fonction de callback ne gardant pas trace du nombre d'échantillons produits. Pour pouvoir lire la structure musicale, on garde donc en mémoire l'endroit exact en nombre d'échantillons d'où la bufferisation en est.\\
Organisation de la structure :
\begin{lstlisting}
var song = {
	title,		// titre du morceau
	tempo, 		// temps d'un bloc en secondes
	blocks, 		// nombre de blocs du morceau
	pitches : {		// liste des hauteurs utilisées dans le morceau
	pitch,		// nombre d'occurrences d'une hauteur
	...
	},
	tracks : [{		// liste des pistes du morceau
		name,			// nom de la piste
		blocks : [{		// liste des blocs d'une piste
			layers : {		// liste des calques d'un bloc
				nbDiv : [[{		// notes actives par colonne
					pitch,
					duration
				}, ...], ...],
			...} // layers
		}, ...] // blocks
	}, ...] // tracks
};
\end{lstlisting}


\section{Avancement}

\subsection{Limitations actuelles et améliorations}

\subsection{Détails techniques}


\section{Manuel d'utilisation}

Ce manuel présente les possibilités offertes à l'utilisateur dans la version actuelle de JaSMEd.

\paragraph{Authentification}~\\
Avant de pouvoir accéder à l'éditeur, il faut s'authentifier. Les utilisateurs autorisés à se connecter sont pour l'instant codé directement dans le fichier \emph{authentification.js}. Nous n'avons pas encore implémenté la création de nouveaux utilisateurs, car ce n'est pas l'objectif premier de l'application.\\
Une fois authentifié, on accède à l'éditeur soit en chargeant un morceau pré-enregistré, soit en partant de zéro avec un nouveau morceau.

\paragraph{Édition}~\\
La partie édition représente une partition musicale à éditer, proposant de sélectionner une note en fonction de sa hauteur, sa durée, et sa position. Il est possible de naviguer verticalement le long des octaves du piano à l'aide de la barre de défilement mais aussi horizontalement sur l'axe du temps en plaçant la souris aux extrémités gauche et droite de la grille.\\
L'ajout d'un nouveau bloc se fait à l'aide du bouton \emph{add block}.\\
Pour ajouter un nouveau calque à un bloc il suffit de préciser le nombre de subdivision souhaité dans le champs de texte au dessus de chaque bloc puis de valider avec \emph{Entrée}. Si le calque existe déjà dans le bloc, aucun calque n'est créé, mais celui désigné par le nombre de subdivision devient alors éditable. Pour changer de calque éditable dans un bloc, il suffit de cliquer sur le bouton symbolisant le calque voulu. Un seul calque par bloc est éditable.\\
Pour créer une note, on peut sélectionner une seul cellule d'un calque, ou faire une sélection de plusieurs cellules. Pour cela, il faut cliquer sur la cellule de début et glisser la souris jusqu'à la cellule de fin de la note avant de relâcher le bouton. La sélection n'est pas visible directement, car pour l'instant seules les notes activées sont affichées.\\
On ne peut pas encore supprimer de notes.\\
L'utilisateur peut aussi exporter son morceau sur le serveur en spécifiant un nom sans accents ni caractère "." dans le champ \emph{export as}.\\
On peut agrandir ou rétrécir la largeur des blocs dans la zone d'édition à l'aide des boutons \emph{zoom in} et \emph{zoom out}.

\paragraph{Lecture}~\\
La lecture du morceau se fait à l'aide du bouton \emph{play}. Une fois lancé, ce dernier se transforme en bouton \emph{pause}, pour arrêter puis reprendre la lecture en cours. Un bouton \emph{stop} est aussi disponible pour réinitialiser la lecture.\\
\emph{Remarque:} un temps de latence entre l'appuie du bouton \emph{play} et la lecture effective du morceau est à noter.

\paragraph{Instrumentation}~\\
Le panneau d'instrumentation permet de choisir le type de l'oscillateur qui jouera la piste lors de la lecture, ainsi que de modifier l'intensité du \emph{sustain} de l'enveloppe ADSR en déplaçant le curseur.


\section{Conclusion}

\pagebreak

\begin{thebibliography}{99}

\bibitem{Crockford}
	Douglas Crockford,
	\emph{JavaScript: The Good Parts}.
	O'Reilly, 2008.

\medskip

\bibitem{Flanagan}
	David Flanagan,
	\emph{JavaScript: The Definitive Guide}.
	O'Reilly, 2011.

\medskip

\bibitem{Zakas}
	Présentation de Nicholas Zakas: 
	\emph{Scalable JavaScript Application Architecture} - 
	\url{http://www.youtube.com/watch?v=vXjVFPosQHw}

\medskip

\bibitem{Addy}
	Article d'Addy Osmani: 
	\emph{Patterns For Large-Scale JavaScript Application Architecture} - 
	\url{http://addyosmani.com/largescalejavascript/}

\medskip

\bibitem{Osmani}
	Article d'Addy Osmani: 
	\emph{Writing Modular JavaScript With AMD, CommonJS \& ES Harmony} - 
	\url{http://addyosmani.com/writing-modular-js/}

\medskip

\bibitem{audiolib}
	Official.fm Labs,
	\emph{Audio Library Application Programming Interface}.\\
	\url{http://audiolibjs.org/}

\end{thebibliography}

\appendix

\end{document}

pb et difficultés:
-MIDI (chap conception)
-largeur de bloc ->affichage non-cohérent, curseur de lecture
-sample décalage
-app scalable -> modulaire/gestion centralisé, MV*
-latence d'initialisation lecture